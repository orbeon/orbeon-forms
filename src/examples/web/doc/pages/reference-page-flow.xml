<!--
    Copyright (C) 2005 Orbeon, Inc.

    The Orbeon documentation is not distributed under the LGPL license. Use of the documentation is
    subject to the following terms:

    * Conversion to other formats is allowed, but the actual content may not be altered or edited
      in any way.

    * You may create printed copies for your own personal use.

    * For all other uses, such as selling printed copies or using (parts of) the manual in another
      publication, prior written agreement from Orbeon, Inc. is required.

    Please contact Orbeon at info@orbeon.com for more information.
-->
<document xmlns:p="http://www.orbeon.com/oxf/pipeline"
          xmlns:xforms="http://www.w3.org/2002/xforms"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <header>
        <title>Page Flow Controller</title>
    </header>
    <body>
        <section>
            <title>Introduction to the Page Flow Controller</title>
            <img print-format="pdf" src="pages/reference-controller-oxf-app.png" style="float: right; margin-left: 1em"/>
            <p>
                The OPS Page Flow Controller (PFC) is the heart of your OPS web application. It
                dispatches incoming user requests to individual pages built out of models and views,
                following the model / view / controller (MVC) architecture.
            </p>
            <p>
                The PFC is configured with a file called a <i>page flow</i>. A page flow not only
                describes the pages offered by your application, it also declaratively describes an
                entire application's navigation logic, allowing the development of pages and XML
                services completely independently from each other.
            </p>
            <p>
                The PFC encourages designing applications with a total separation between:
            </p>

            <ul>
                <li>
                    <p>
                        <b>Site Logic</b> or <b>Page Flow</b>: when, and how to navigate from one
                        page to another.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Page Logic</b> (the MVC page model): how data entered by the user is
                        processed (for example validated, then fed to a backend), and how data is
                        retrieved from a backend.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Page Layout</b> (the MVC page view): how information is displayed and
                        presented to the user.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Site Presentation</b>: the layout and look and feel common to all pages
                        in the web application or the web site, e.g.: site navigation menus,
                        headers and footers, table backgrounds, or number formatting.
                    </p>
                </li>
            </ul>
            <note>
                <p>
                    By default, the PFC is configured in <code>web.xml</code> as the main processor
                    for the OPS servlet and portlet. However, you are not required to use the PFC
                    with OPS: you can define your own main processor for servlets and portlets, as
                    documented in <a href="integration-packaging#main-processor">Packaging and
                    Deployment</a>. For most web applications, the PFC should be used.
                </p>
            </note>
        </section>
        <a name="basics"/>
        <section>
            <title>Basics</title>
            <section>
                <title>Page Flow Configuration</title>
                <p>
                    A page flow is usually defined in a file called <code>page-flow.xml</code>
                    stored at the root of your OPS resources. This XML file has a root element
                    called <code>&lt;config&gt;</code>, which has to be within the
                    <code>http://www.orbeon.com/oxf/controller</code> namespace. All the XML
                    elements in a page flow have to be in that namespace unless stated otherwise.
                    You start a page flow document as follows:
                </p>
                <xml-source>
                    <config xmlns="http://www.orbeon.com/oxf/controller">
                        ...
                    </config>
                </xml-source>
                <p>
                    You can configure the location of the page flow configuration file in the web
                    application's <code>web.xml</code> file. See <a
                    href="integration-packaging">Packaging and Deployment</a> for more information.
                    In most cases, it is not necessary to change the default name and location.
                </p>
            </section>
            <a name="pages"/>
            <section>
                <title>Pages</title>
                <p>
                    Most web applications consist of a set of <i>pages</i>, identified to clients (web
                    browsers) by a certain URL, for example:
                </p>
                <blockquote>
                    <code>http://www.orbeon.org/myapp/report/detail?first=12&amp;count=10#middle</code>
                </blockquote>
                <p>
                    In most cases the URL can be split as follows:
                </p>
                <ul>
                    <li>
                        <p><code>http://www.orbeon.org/</code> identifies the web or application server
                        hosting the application.</p>
                    </li>
                    <li>
                        <p><code>/myapp</code> may optionally identify the particular web application
                        running on that server. Whils this part of the URL path is not mandatory, its
                        use is encouraged on Java application servers, where it is called the <i>context
                        path</i>.</p>
                    </li>
                    <li>
                        <p><code>/report/detail</code> identifies the particular page within the web
                        application. Such a path may be "flat", or hierarchical, separated with "/"
                        (slashes).</p>
                    </li>
                    <li>
                        <p><code>?first=12&amp;count=10</code> specifies an optional <i>query
                        string</i> which identifies zero or more <i>parameters</i> passed to that
                        page. Each parameter has a value. This example has two parameters: the
                        first one is called <code>first</code> with value <code>12</code>, and the
                        second one is called <code>count</code> with value <code>10</code>.</p>
                    </li>
                    <li>
                        <p><code>#middle</code> is an optional fragment identifier identifying a section
                        of the resulting page. Usually, this part of the URL is not handled by the web
                        application, instead the web browser uses it to scroll to a section of the
                        resulting page identified by this identifier (here <code>middle</code>).</p>
                    </li>
                </ul>
                <p>
                    For a particular web application, what usually matters in order to identify a
                    particular page is the path within the URL under the context
                    path, here <code>/report/detail</code>. Therefore, in an OPS page flow, each
                    page is identified with a unique path information. You declare a minimal page
                    like this:
                </p>
                <xml-source>
                    <page path-info="/report/detail"/>
                </xml-source>
                <p>
                    Other pages may be declared as follows:
                </p>
                <xml-source>
                    <page path-info="/report/summary"/>
                    <page path-info="/home"/>
                </xml-source>
                <p>
                    A <code>&lt;page&gt;</code> element can have an optional <code>id</code>
                    attribute useful for <a href="#page-navigation">navigating between pages</a>.
                </p>
            </section>
            <a name="simple-pages"/>
            <section>
                <title>Simple Pages</title>
                <p>
                    Creating a static page with OPS is quite easy: just add a <code>view</code>
                    attribute on a <code>&lt;page&gt;</code> element which points to an XHTML file:
                </p>
                <xml-source>
                    <page path-info="/report/detail" view="oxf:/report/detail/report-detail-view.xhtml"/>
                </xml-source>
                <p>
                    Here, using the <code>oxf:</code> protocol means that the file is searched
                    through the OPS <a href="reference-resource-managers">resource manager</a>
                    sandbox. It is also possible to use relative paths, for example:
                </p>
                <xml-source>
                    <page path-info="/report/detail" view="report/detail/report-detail-view.xhtml"/>
                </xml-source>
                <p>
                    The path is relative to the location of the page flow configuration file where
                    the <code>&lt;page&gt;</code> element is contained. Here is an example of the
                    content of <code>report-detail-view.xhtml</code>:
                </p>
                <xml-source>
                    <xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml">
                        <xhtml:head>
                            <xhtml:title>Hello World Classic</xhtml:title>
                        </xhtml:head>
                        <xhtml:body>
                            <xhtml:p>Hello World!</xhtml:p>
                        </xhtml:body>
                    </xhtml:html>
                </xml-source>
                <p>
                    It is recommended to to use XHTML and to put all the elements in the XHTML
                    namespace, <code>http://www.w3.org/1999/xhtml</code>. This can be done by using
                    default namespace declaration on the root element
                    (<code>xmlns="http://www.w3.org/1999/xhtml</code>) or by mapping the namespace to a
                    prefix such as <code>xhtml</code> and to use that prefix throughout the document, as
                    shown above. The file must contain well-formed XML: just using a legacy HTML file
                    won't work without some adjustments, usually minor.
                </p>
                <p>
                    Instead of using a static XHTML page, you can also use an XSLT template to generate
                    a dynamic page. This allows using XSLT constructs mixed with XHTML constructs, for
                    example:
                </p>
                <xml-source>
                    <html xmlns="http://www.w3.org/1999/xhtml"
                          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                          xsl:version="2.0">
                        <head>
                            <title>Current Time</title>
                        </head>
                        <body>
                            <p>The time is now <xsl:value-of select="current-dateTime()"/>!</p>
                        </body>
                    </html>
                </xml-source>
                <p>
                    When XSLT templates are used, it is recommended to use the <code>.xsl</code>
                    extension:
                </p>
                <xml-source>
                    <page path-info="/report/detail" view="report/detail/report-detail-view.xsl"/>
                </xml-source>
            </section>
            <a name="page-model-page-view"/>
            <section>
                <title>Page Model and Page View</title>
                <img print-format="pdf" src="pages/reference-controller-mvc.png" style="float: right; margin-left: 1em"/>
                <p>
                    In the MVC architecture, the page logic is implemented by a <i>page model</i>, and
                    the page layout by a <i>page view</i>. The MVC architecture promotes the separation
                    of model, view and controller:
                </p>

                <ul>
                    <li>
                        <p>
                            <b>The page model</b> is responsible for calling or implementing the
                            business logic. It is in charge of gathering the information to be displayed
                            by the page view.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>The page view</b> is in charge of presenting to the user the
                            information gathered by the page model. The page view usually produces
                            XHTML and XForms, but it can also produce other results such as XSL-FO,
                            RSS, etc. Handling of the output of the view is done in the <a
                            href="reference-epilogue">page flow epilogue</a>, which by default
                            knows how to handle XHTML, XForms, XSL-FO, and custom XML document.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>The controller</b> is responsible for dispatching a request from a client
                            such as a web browser to the appropriate page model and view and connecting
                            the model with the view. In OPS, the controller is the PFC itself, which is
                            configured with a page flow.
                        </p>
                    </li>
                </ul>
                <p>
                    For instance, a news page can use a page model to retrieve the list of headlines and
                    then pass this information as an XML document to a page view. The view produces an
                    XHTML page by creating a table with the content of the headlines, adding a logo at
                    the top of the page, a copyright notice at the bottom, etc.
                </p>
                <p>
                    Each PFC <code>&lt;page&gt;</code> element therefore supports attributes defining
                    what page model and page view must be used:
                </p>
                <ul>
                    <li>
                        <p>
                            The <code>model</code> attribute is a URL refering to an <a
                            href="reference-xpl-pipelines">XPL pipeline</a> (optionally an XSLT
                            stylesheet or a static XML file) implementing the model.
                        </p>
                    </li>
                    <li>
                        <p>
                            The <code>view</code> attribute is a URL refering to an XSLT stylesheet
                            (optionally an <a href="reference-xpl-pipelines">XPL pipeline</a> or a
                            static XML file) implementing the view.
                        </p>
                    </li>
                </ul>
                <p>
                    The model passes data to the view as an XML document, as follows:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>XPL model.</b> The model document must be generated by the <a
                            href="reference-xpl-pipelines">XPL pipeline</a> on an output named
                            <code>data</code>.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XSLT model.</b> The model document is the default output of the XSLT
                            transformation.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Static XML model.</b> The model document is the static XML document
                            specified.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XPL view.</b> The model document is available on an input named
                            <code>data</code>.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XSLT view.</b> The model document is available as the default input of
                            the XSLT transformation.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Static XML view.</b> In this case, no model document is available to the
                            view.
                        </p>
                    </li>
                </ul>
                <p>
                    A model <a href="reference-xpl-pipelines">XPL pipeline</a> and an XSLT view can
                    be declared as follows for the <code>/report/detail</code> page:
                </p>
                <xml-source>
                    <page path-info="/report/detail" model="report/detail/report-detail-model.xpl" view="report/detail/report-detail-view.xsl"/>
                </xml-source>
                <p>
                    Here, the location of the model and view definitions mirrors the path of the page,
                    and file names repeat the directory path, so that files can be searched easier. It
                    is up to the developer to choose a naming convention, but it is recommended to
                    follow a consistent naming structure. Other possibilities include:
                </p>
                <xml-source>
                    <page path-info="/report/detail" model="report-detail-model.xpl" view="report-detail-view.xsl"/>
                </xml-source>
                <p>
                    or:
                </p>
                <xml-source>
                    <page path-info="/report/detail" model="models/report-detail-model.xpl" view="views/report-detail-view.xsl"/>
                </xml-source>
                <p>
                    A typical XSLT view can extract model data passed to it automatically by the PFC on
                    its default input, for example, if the model generates a document containing the
                    following:
                </p>
                <xml-source>
                    <employee>
                        <name>John Smith</name>
                    </employee>
                </xml-source>
                <p>
                    Then an XSLT view can display the content of the <code>&lt;name&gt;</code> element
                    as follows:
                </p>
                <xml-source>
                    <html xmlns="http://www.w3.org/1999/xhtml"
                          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                          xsl:version="2.0">
                        <head>
                            <title>Hello World MVC</title>
                        </head>
                        <body>
                            <p>Hello <xsl:value-of select="/employee/name"/>!</p>
                        </body>
                    </html>
                </xml-source>
            </section>
        </section>
        <a name="xml-submission"/>
        <section>
            <title>XML Submission</title>
            <section>
                <title>Rationale</title>
                <p>
                    A page built out of a model and a view can retrieve information from a data
                    source and format it. However, this is not enough to make a page which can use
                    parameters submitted by a client to configure what data is being presented, or
                    how it is presented.
                </p>
                <p>
                    The OPS PFC uses the concept of <i>XML submission</i> to provide page
                    configurability. To the model and view of a given page, an XML submission is
                    simply an XML document whose content is available as an <a
                    href="reference-xpl-pipelines">XPL pipeline</a> or an XSLT input called
                    <code>instance</code>.
                </p>
                <p>
                    There are different ways to produce an XML submission:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>Internal XForms submission.</b> The built-in OPS XForms engine uses
                            an HTTP POST XForms submission to submit an XForms instance.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>External submission.</b> An external application or a client-side XForms
                            engine uses HTTP POST to submit an XML document directly to a page.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>PFC page navigation.</b> The PFC, based on a user configuration,
                            produces an XML document to submit internally to a given page.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Default submission.</b> Each page can refer to a <i>default submission
                            document</i> containing an XML document automatically submitted to the page
                            if no other submission is done.
                        </p>
                    </li>
                    <p>

                    </p>
                </ul>
            </section>
            <a name="internal-submission"/>
            <section>
                <title>Internal XForms Submission</title>
                <p>
                    The most common case of XML submission in OPS is submission from the built-in
                    XForms engine. Assume you have a page defined as follows:
                </p>
                <xml-source>
                    <page path-info="/report/detail" model="report/detail/report-detail-model.xpl" view="report/detail/report-detail-view.xsl"/>
                </xml-source>
                <p>
                    If you wish to submit an XForms instance to this page from within
                    <code>report-detail-view.xsl</code>, create an XForms submission as follows:
                </p>
                <xml-source>
                    <xforms:submission id="main" method="post" action="/report/detail"/>
                </xml-source>
                <p>
                    This ensures that when this XForms submission is activated, an XML document
                    containing the submitted XForms instance will be made available to the page
                    model and view.
                </p>
                <note>
                    <p>
                        The <code>action</code> attribute on the <code>xforms:submission</code>
                        element should not be confused with the <code>&lt;action&gt;</code> element
                        of the page flow. The former specifies a URL to which the XForms submission
                        must be performed, as per the XForms 1.0 recommendation; the latter
                        specifies a PFC <a href="#action-element">action</a> executed when a
                        specified boolean XPath expression operating on an XML submission evaluates
                        to true. The XForms submission's <code>action</code> attribute instead
                        matches a PFC <code>&lt;page&gt;</code> element's <code>path-info</code>
                        attribute.
                    </p>
                </note>
<!--                <note>-->
                    <p>
                        You can also directly submit to another page by specifying a different
                        action, for example:
                    </p>
                    <xml-source>
                        <xforms:submission id="main" method="post" action="/report/summary"/>
                    </xml-source>
                    <p>
                        In general it is recommended to leave the control of the flow between pages
                        to PFC <i>actions</i>, as documented below.
                    </p>
<!--                </note>-->
            </section>
            <a name="external-submission"/>
            <section>
                <title>External XML Submission</title>
                <p>
                    An external XML submission must refer to the URL of the page accepting the
                    submission. It is up to the developer to provide this URL to the external
                    application, for example <code>http://www.orbeon.org/myapp/xmlrpc</code> if you
                    have a page declaring the path <code>/xmlrpc</code>:
                </p>
                <xml-source>
                    <page path-info="/xmlrpc" model="xmlrpc.xpl"/>
                </xml-source>
                <p>
                    The <a href="/goto-example/blog">Blog</a> and <a
                    href="/goto-example/employees">Employees</a> examples illustrate the
                    implementation of XML-RPC and web services handlers using this mechanism.
                </p>
            </section>
            <a name="default-submission"/>
            <section>
                <title>Default Submission</title>
                <p>
                    In case there is no external or internal XML submission, it is possible to
                    specify a static default XML submission document. This is particularly useful to
                    extract information from a page URL, as documented below. You specify a default
                    submission with the <code>default-submission</code> attribute as follows:
                </p>
                <xml-source>
                    <page path-info="/report/detail" default-submission="report-detail-default-submission.xml"/>
                </xml-source>
            </section>
            <a name="accessing-submission"/>
            <section>
                <title>Accessing XML Submission Data</title>
                <p>
                    The mechanisms described above explain how a page receives an XML submission,
                    but not how to actually access the submitted XML document. You do this in one of
                    the following ways:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>XPL model.</b> The model accesses the XML submission document from its
                            <code>instance</code> input.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XSLT model.</b> The model accesses the XML submission document using
                            the <code>doc('input:instance')</code> function.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Static XML model.</b> The model cannot access the XML submission
                            document.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XPL view.</b> The view accesses the XML submission document from its
                            <code>instance</code> input.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>XSLT view.</b> The view accesses the XML submission document using
                            the <code>doc('input:instance')</code> function.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Static XML view.</b> The view cannot access the XML submission
                            document.
                        </p>
                    </li>
                </ul>
                <p>
                    If no submission has taken place, the XML submission document is an OPS "null"
                    document, as follows:
                </p>
                <xml-source>
                    <null xsi:nil="true"/>
                </xml-source>
            </section>
            <a name="url-extraction"/>
            <section>
                <title>Extracting Data From the URL</title>
                <p>
                    XML submission using HTTP POST convenient in many cases, however there are other
                    ways page developers would like to configure the way a page behaves:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>Using URL parameters.</b> URL parameters are specified in a query
                            string after a question mark in the URL, explained above.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Using URL path elements.</b> URL paths can be hierarchical, and the
                            elements of the paths can have a user-defined meaning.
                        </p>
                    </li>
                </ul>
                <p>
                    A PFC page can easily extract data from the URL using the
                    <code>&lt;setvalue&gt;</code> element nested within the
                    <code>&lt;page&gt;</code> element. To do so, an XML submission must take place
                    on the page. This can be achieved by using the default submission if no other
                    submission is taking place. The default submission document must contain
                    placeholders for for the values to extract from the URL. Given an URL query
                    string of <code>first=12&amp;count=10</code> with two parameters,
                    <code>first</code> and <code>count</code>, a default sumission document can look
                    as follows:
                </p>
                <xml-source>
                    <submission>
                        <first/>
                        <count/>
                    </submission>
                </xml-source>
                <p>
                    The following page extracts the two URL parameters:
                </p>
                <xml-source>
                    <page path-info="/report/detail" default-submission="report-detail-default-submission.xml">
                        <setvalue ref="/submission/first" parameter="first"/>
                        <setvalue ref="/submission/count" parameter="count"/>
                    </page>
                </xml-source>
                <p>
                    The <code>&lt;setvalue&gt;</code> element uses the <code>ref</code> attribute,
                    which contains an XPath 2.0 expression identifying exactly one element or
                    attribute in the XML document. The text value of the element or attribute is
                    then set with the value of the URL parameter specified. If there is no parameter
                    with a matching name, the element or attribute is not modified. This allows
                    using default values, for example:
                </p>
                <xml-source>
                    <submission>
                        <first/>
                        <count>5</count>
                    </submission>
                </xml-source>
                <p>
                    In such a case, if no <code>count</code> parameter is specified on the URL, the
                    default value will be available.
                </p>
                <p>
                    With a query string of <code>first=12&amp;count=10</code>, the resulting XML
                    document will be:
                </p>
                <xml-source>
                    <submission>
                        <first>12</first>
                        <count>10</count>
                    </submission>
                </xml-source>
                <p>
                    With a query string of <code>first=12</code>, the resulting XML document will
                    be:
                </p>
                <xml-source>
                    <submission>
                        <first>12</first>
                        <count>5</count>
                    </submission>
                </xml-source>
                <note>
                    <p>
                        The default submission document does not have to use element or attribute
                        names identical to the URL parameter names. Doing so however may make the
                        code clearer.
                    </p>
                </note>
                <p>
                    If there are multiple URL parameters with the same name, they will be stored in
                    the element or attribute separated by spaces.
                </p>
                <p>
                    It is also possible to extract data from the URL path. To do so, use a
                    <code>matcher</code> attribute on the page as <a href="#matchers">documented
                    below</a>. You can then extract regular expression groups using the
                    <code>&lt;setvalue&gt;</code> element with the <code>matcher-group</code>
                    attribute:
                </p>
                <xml-source>
                    <page path-info="/blog/([^/]+)/([^/]+)" matcher="oxf:perl5-matcher"
                          default-submission="recent-posts/recent-posts-default-submission.xml"
                          model="recent-posts/recent-posts-model.xpl"
                          view="recent-posts/recent-posts-view.xpl">
                        <setvalue ref="/form/username" matcher-group="1"/>
                        <setvalue ref="/form/blog-id" matcher-group="2"/>
                    </page>
                </xml-source>
                <p>
                    The <code>matcher-group</code> attribute contains a positive integer identifying
                    the number of the regular expression group to extract. With a path of
                    <code>/blog/jdoe/456</code>, the first group contains the value
                    <code>jdoe</code>, and the second group the value <code>456</code>.
                </p>
            </section>
            <note>
                <p>
                    If a page actually uses an XML submission, which means either having
                    <code>&lt;action&gt;</code> elements, or reading the instance in the page model
                    or page view, it must not expect to be able to read the HTTP request body
                    separately using the <a href="processors-generators-request">Request
                    generator</a>.
                </p>
            </note>
        </section>
        <a name="page-navigation"/>
        <section>
            <title>Navigating Between Pages</title>
            <section>
                <title>Page Flow</title>
                <img print-format="pdf" src="pages/reference-controller-navigation.png"
                    style="float: right; margin-left: 1em"/>
                <p>
                    The site logic or page flow describes the conditions that trigger the
                    navigation from one page to the other. It also describes how arguments are
                    passed from one page to the other. In a simple web application simulating an
                    ATM, as illustrated by the <a href="/goto-example/atm">ATM example</a> the
                    navigation logic could look like the one described in the diagram on the right.
                    In this diagram, the square boxes represent pages and diamond-shaped boxes
                    represent actions performed by the end-user.
                </p>
                <p>
                    With the PFC, page flow is expressed declaratively and externally to the pages.
                    Consequently, pages can be designed independently from each other. The
                    benefits of a clear separation between site logic and page logic and layout
                    include:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>Simplicity:</b> the site logic is declared in one place and in a
                            declarative way. You don't need to write custom logic to perform
                            redirects between pages or pass arguments from page to page.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Maintainability:</b> having different developers implementing
                            independent page is much easier. Since the relationship between pages is
                            clearly stated in the page flow, it also becomes much easier to modify
                            a page in an existing application without affecting other pages.
                        </p>
                    </li>
                </ul>
            </section>
            <a name="actions-results"/>
            <section>
                <title>Actions and Results</title>
                <section>
                    <title>An Example</title>
                    <p>
                        Consider a <code>view-account</code> page in the ATM web application. The page
                        displays the current balance and lets the user enter an amount of money to
                        withdraw from the account. The page looks like this:
                    </p>
                    <img print-format="png" src="pages/reference-controller-atm-screen.png" width="401" height="126"/>
                    <p>
                        This page is composed of different parts illustrated in the figure below:
                    </p>
                    <ul>
                        <li>
                            <p>
                                <b>The page model</b> retrieves the current balance.
                            </p>
                        </li>
                        <li>
                            <p>
                                <b>The page view</b> displays the balance, and presents a form for the
                                user to enter the amount to withdraw.
                            </p>
                        </li>
                        <li>
                            <p>
                                <b>An action</b> executed when the user enters an amount in the text
                                field. This action checks if the amount entered is inferior or equal to
                                the account balance. If it is, the balance is decreased by the amount
                                entered and the transaction is considered valid. Otherwise, the
                                transaction is considered illegal. Depending on the validity of the
                                transaction, a different page is displayed. If the transaction is
                                valid, the <code>anything-else</code> page is displayed; otherwise the
                                <code>low-balance</code> page is displayed.
                            </p>
                        </li>
                    </ul>
                    <img print-format="pdf" src="pages/reference-controller-atm-logic.png"/>
                    <p>
                        This behavior is described in the Page Flow with:
                    </p>
                    <xml-source>
                        <page id="view-account" path-info="/view-account" model="view-account-get-balance-model.xpl" view="view-account-get-balance-view.xsl">
                            <action when="/amount != ''" action="view-account-action.xpl">
                                <result id="success" when="/success = 'true'" page="anything-else"/>
                                <result id="failure" when="/success = 'false'" page="low-balance"/>
                            </action>
                        </page>
                    </xml-source>
                </section>
                <section>
                    <title>The <code>&lt;page&gt;</code> element</title>
                    <p>
                        On the <code>&lt;page&gt;</code> element, as documented above:
                    </p>
                    <ul>
                        <li>
                            <p>
                                The <code>path-info</code> attribute tells the PFC what relative
                                URL corresponds to this page. The URL is relative to the
                                application context path.
                            </p>
                        </li>
                        <li>
                            <p>
                                The <code>model</code> attribute points to the page model <a
                                href="reference-xpl-pipelines">XPL pipeline</a>.
                            </p>
                        </li>
                        <li>
                            <p>
                                The <code>view</code> attribute points to the page view XSLT template.
                            </p>
                        </li>
                    </ul>
                </section>
                <a name="action-element"/>
                <section>
                    <title>The <code>&lt;action&gt;</code> element</title>
                    <p>
                        The <code>&lt;page&gt;</code> element contains an
                        <code>&lt;action&gt;</code> element. It is named <i>action</i> because it is
                        typically executed as a consequence of an action performed by the end-user,
                        for example by clicking on a button or a link which causes a form to be
                        submitted. There may be more than one <code>&lt;action&gt;</code> element
                        within a <code>&lt;page&gt;</code> element element. On an
                        <code>&lt;action&gt;</code> element:
                    </p>
                    <ul>
                        <li>
                            <p>
                                The <code>when</code> attribute contains an XPath 2.0 expression
                                executed against the XML submission. The first
                                <code>&lt;action&gt;</code> element with a <code>when</code>
                                attribute evaluating to <code>true()</code> is executed. The
                                <code>when</code> attribute is optional: a missing <code>when</code>
                                attribute is equivalent to <code>when="true()"</code>. Only the last
                                <code>&lt;action&gt;</code> element is allowed to have a missing
                                <code>when</code> attribute. This allows for defining a default
                                action which executes if no other action can execute.
                            </p>
                        </li>
                        <li>
                            <p>
                                When the action is executed, if the optional <code>action</code>
                                attribute is present, the <a href="reference-xpl-pipelines">XPL
                                pipeline</a> it points to is executed.
                            </p>
                        </li>
                    </ul>
                </section>
                <a name="result-element"/>
                <section>
                    <title>The <code>&lt;result&gt;</code> element</title>
                    <p>
                        The <code>&lt;action&gt;</code> element can contain zero or more
                        <code>&lt;result&gt;</code> elements.
                    </p>
                    <ul>
                        <li>
                            <p>
                                If an <code>action</code> attribute is specified on the
                                <code>&lt;action&gt;</code> element, the <code>&lt;result&gt;</code>
                                element can have a <code>when</code> attribute. The
                                <code>when</code> attribute contains an XPath 2.0 expression
                                executed against the <code>data</code> output of the action <a
                                href="reference-xpl-pipelines">XPL pipeline</a>. The first
                                <code>&lt;result&gt;</code> evaluating to <code>true()</code> is
                                executed. The <code>when</code> attribute is optional: a missing
                                <code>when</code> attribute is equivalent to
                                <code>when="true()"</code>. Only the last
                                <code>&lt;result&gt;</code> element is allowed to have a missing
                                when attribute. This allows for defining a default action result
                                which executes if no other action result can execute.
                            </p>
                        </li>
                        <li>
                            <p>
                                A <code>&lt;result&gt;</code> element optionally has a
                                <code>page</code> attribute. The <code>page</code> attribute
                                contains a page id pointing to a page declared in the same page
                                flow. When the result is executed and the <code>page</code>
                                attribute is present, the destination page is executed, and the user
                                is forwarded to the corresponding page.
                            </p>
                            <note>
                                <p>
                                    In this case, a page model or page view specified on the
                                    enclosing <code>&lt;page&gt;</code> element does not execute!
                                    Instead, control is transferred to the page with the identifier
                                    specified. This also means that the <a
                                    href="#epilogue-element">page flow epilogue</a> does not
                                    execute.
                                </p>
                            </note>
                        </li>
                        <li>
                            <p>
                                A <code>&lt;result&gt;</code> element can optionally contain an XML
                                submission. The submission can be created using XSLT, XQuery, or the
                                deprecated XUpdate. You specify which language to use with the
                                <code>transform</code> attribute on the <code>&lt;result&gt;</code>
                                element. The inline content of the <code>&lt;result&gt;</code>
                                contains then a transformation in the language specified. Using XSLT
                                is recommended.
                            </p>
                            <p>
                                The transformation has automatically access to:
                            </p>
                            <ul>
                                <li>
                                    <p>
                                        An <code>instance</code> input, containing the current XML
                                        submission. From XSLT, XQuery and XUpdate, this input is
                                        available with the <code>doc('input:instance')</code>
                                        function. If there is no current XML submission, a "null"
                                        document is available instead:
                                    </p>
                                    <xml-source>
                                        <null xsi:nil="true"/>
                                    </xml-source>
                                </li>
                                <li>
                                    <p>
                                        An <code>action</code> input, containing the result of the
                                        action <a href="reference-xpl-pipelines">XPL pipeline</a> if
                                        present. From XSLT, XQuery and XUpdate, this input is
                                        available with the <code>doc('input:action')</code>
                                        function. If there is no action result, a "null" document
                                        is available instead:
                                    </p>
                                    <xml-source>
                                        <null xsi:nil="true"/>
                                    </xml-source>
                                </li>
                                <li>
                                    <p>
                                        The default usually contains the current current XML
                                        submission as available from the <code>instance</code>
                                        input.
                                    </p>
                                    <p>
                                        For backward compatibility however, when the destination
                                        page has an <code>xforms</code> attribute, the default input
                                        contains instead the destination page's resulting XForms
                                        instance.
                                    </p>
                                </li>
                            </ul>
                            <p>
                                The result of the transformation is automatically submitted to the
                                destination page. If there is no destination page, it replaces the
                                current XML submission document made availabe to the page model and
                                page view.
                            </p>
                         </li>
                    </ul>
                    <p>
                        An action <a href="reference-xpl-pipelines">XPL pipeline</a> supports an
                        optional <code>instance</code> input containing the current XML submission,
                        and produces an optional <code>data</code> output with an action result
                        document which may be used by a <code>&lt;result&gt;</code> element's
                        <code>when</code> attribute, as well as by an XML submission-producing
                        transformation. This is an example of action XPL pipeline:
                    </p>
                    <xml-source>
                        <p:config xmlns:p="http://www.orbeon.com/oxf/pipeline"
                                  xmlns:oxf="http://www.orbeon.com/oxf/processors">

                            <p:param name="instance" type="input"/>
                            <p:param name="data" type="output"/>

                            <comment> Call the data access layer </comment>
                            <p:processor name="oxf:pipeline">
                                <p:input name="config" href="../data-access/delegate/read-document.xpl"/>
                                <p:input name="document-id" href="#instance#xpointer(/*/document-id)"/>
                                <p:output name="document-info" ref="data"/>
                            </p:processor>

                        </p:config>
                    </xml-source>
                    <p>
                        Notice the <code>instance</code> input, the <code>data</code> output, as
                        well as a call to a data access layer which uses information from the XML
                        submission and directly returns an action result document.
                    </p>
                    <p>
                        The following is an example of using XSLT within <code>&lt;result&gt;</code>
                        element in order to produce an XML submission passed to a destination page:
                    </p>
                    <xml-source>
                        <action when="/form/action = 'show-detail'" action="../bizdoc/summary/find-document-action.xpl">
                            <result page="detail" transform="oxf:xslt">
                                <form xsl:version="2.0" xmlns="">
                                    <document-id><xsl:value-of select="doc('input:action')/document-info/document-id"/></document-id>
                                    <document><xsl:copy-of select="doc('input:action')/document-info/document/*"/></document>
                                </form>
                            </result>
                        </action>
                    </xml-source>
                    <p>
                        Notice the <code>transform</code> attribute set to <code>oxf:xslt</code>,
                        and the use of the <code>doc('input:action')</code> to refer to the output
                        of the action XPL pipeline specified by the <code>action</code> attribute on
                        the <code>&lt;action&gt;</code> element. The current XML submission can also
                        be accessed with<code>doc('input:instance')</code>.
                    </p>
                </section>
                <p>
                    See the following examples to understand how <code>&lt;page&gt;</code>,
                    <code>&lt;action&gt;</code>, and <code>&lt;result&gt;</code> can be used in a
                    page flow:
                </p>
                <ul>
                    <li>
                        <p>
                            The simple <a href="/goto-example/atm">ATM</a> example.
                        </p>
                    </li>
                    <li>
                        <p>
                            The <a href="/goto-example/bizdoc2">BizDoc</a> example.
                        </p>
                    </li>
                </ul>
                <p>
                    Also see the <a href="/doc/pages/OPS Tutorial.pdf">OPS Tutorial</a>.
                </p>
            </section>
            <a name="internal-xml-submissions"/>
            <section>
                <title>Controlling Internal XML Submissions</title>
                <p>
                    You can control what method is used to perform an internal XML submission
                    described within a <code>&lt;result&gt;</code> element. Consider this page
                    flow:
                </p>
                <xml-source>
                    <page id="a" path-info="/a" model="..." view="...">
                        <action when="...">
                            <result page="b"/>
                        </action>
                    </page>
                    <page id="b" path-info="/b" model="..." view="..."/>
                </xml-source>
                <p>
                    Going from page "a" to page "b" can be done with either a "forward" or a
                    "redirect" method:
                </p>
                <table>
                    <tr>
                        <th>Redirect</th>
                        <td>
                            <img print-format="pdf" src="pages/home-changes-forward.png"/>
                        </td>
                    </tr>
                    <tr>
                        <th>Forward</th>
                        <td>
                            <img print-format="pdf" src="pages/home-changes-redirect.png"/>
                        </td>
                    </tr>
                </table>
                <p>
                    The benefit of the "redirect" method is that after being redirected to page
                    <i>b</i>, the end-user will see a URL starting with <code>/b</code> in the
                    browser's address bar. He will also be able to bookmark that page and to come
                    back to it later. However, a drawback is that the request for page <i>b</i> is
                    sent by the browser with a <code>GET</code> method. Since browsers impose
                    limits on the maximum amount of information that can be sent in a
                    <code>GET</code> (URL length), this method might not work if the amount of
                    information that needs to be passed to page <i>b</i> from page <i>a</i> is too
                    large. This typically happens when working with fairly large XML submissions.
                    In those cases, you must use the "forward" method, which does not limit the
                    amount of information passed from page to page. The "forward" method also
                    reduces the number of roundtrips with the server.
                </p>
                <note>
                    <p>
                        A third instance passing option, <code>redirect-exit-portal</code>, behaves
                        like the <code>redirect</code> method but sends a redirection which exits
                        the portal, if any. This is mainly useful for the OPS examples portal.
                    </p>
                </note>
                <p>
                    You can configure the method:
                </p>
                <ol>
                    <li>
                        <p>
                            At the application level, in <code>properties.xml</code> with:
                        </p>
                        <xml-source>
                            <property as="xs:string" processor-name="oxf:page-flow" name="instance-passing" value="forward|redirect"/>
                        </xml-source>
                    </li>
                    <li>
                        <p>
                            At the page flow level with the <code>instance-passing</code> attribute
                            on the page flow root element:
                        </p>
                        <xml-source>
                            <config instance-passing="forward|redirect">...</config>
                        </xml-source>
                    </li>
                    <li>
                        <p>
                            In the page flow at the "result" level, with the
                            <code>instance-passing</code> attribute on the <code>&lt;result></code>
                            element:
                        </p>
                        <xml-source>
                            <page id="a" path-info="/a" model="..." view="...">
                                <action when="...">
                                    <result page="b" instance-passing="forward|redirect"/>
                                </action>
                            </page>
                        </xml-source>
                    </li>
                </ol>
                <p>
                    A configuration at the application level (<code>properties.xml</code>) can be
                    overridden by a configuration at the page flow level
                    (<code>instance-passing</code> on the root element), which can in its turn be
                    overridden by a configuration at the result level (<code>instance-passing</code>
                    on the <code>&lt;result></code> element).
                </p>
            </section>
        </section>
        <a name="other-elements"/>
        <section>
            <title>Other Configuration Elements</title>
            <section>
                <title>Overview</title>
                <p>
                    A page flow file is comprised of three sections:
                </p>
                <ul>
                    <li>
                        <p>
                            The <code>&lt;files&gt;</code> elements list files that must be served
                            directly to the client, such as images or CSS files.
                        </p>
                    </li>
                    <li>
                        <p>
                            The <code>&lt;page&gt;</code> elements declare pages and for each one
                            specify identifier, path, model, view, and XML submission.
                        </p>
                    </li>
                    <li>
                        <p>
                            The <code>&lt;epilogue&gt;</code> and
                            <code>&lt;not-found-handler&gt;</code> elements define additional
                            behavior that apply to all the pages.
                        </p>
                    </li>
                </ul>
            </section>
            <a name="files"/>
            <section>
                <title>The files Element</title>
                <p>
                    Some files are not dynamically generated and are served to the client as-is.
                    This is typically the case for images such as GIF, JPEG, CSS files, etc..
                </p>
                <p>
                    You tell the PFC what files to serve directly with one or more
                    <code>&lt;files&gt;</code> elements in the page flow. The example below shows
                    the configuration used by the OPS examples:
                </p>
                <xml-source>
                    <config>
                        <files path-info="*.gif"/>
                        <files path-info="*.css"/>
                        <files path-info="*.pdf"/>
                        <files path-info="*.js"/>
                        <files path-info="*.png"/>
                        <files path-info="*.jpg"/>
                        <files path-info="*.wsdl"/>
                        <files path-info="*.html" mime-type="text/html"/>
                        <files path-info="*.java" mime-type="text/plain"/>
                        <files path-info="*.txt" mime-type="text/plain"/>
                        <files path-info="*.xq" mime-type="text/plain"/>
                        ...
                    </config>
                </xml-source>
                <p>
                    With <code>&lt;files path-info="*.gif"/&gt;</code>, if a request reaches the
                    PFC with the path <code>images/logo.gif</code>, the file
                    <code>oxf:/images/logo.gif</code> is sent in response to that request.
                </p>
                <p>
                    The <code>&lt;files&gt;</code> element supports the <a
                    href="#matchers"><code>path-info</code> and <code>matcher</code></a> attributes
                    like the <code>&lt;page&gt;</code> element. It also supports a
                    <code>mime-type</code> attribute telling the PFC what media type must be sent
                    to the client with the files. The PFC uses defaults for well-known extension,
                    as defined by the <a href="processors-other#resource-server">Resource Server
                    processor</a>. In doubt, you can specify the <code>mime-type</code> attribute.
                </p>
            </section>
            <a name="matchers"/>
            <section>
                <title>Paths and Matchers</title>
                <p>
                    The value of the <code>path-info</code> attribute can be either a simple pattern
                    or a custom pattern.
                </p>
                <table ca="|l|p{0.5\textwidth}|">
                    <tr>
                        <th>Value</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Simple Pattern</td>
                        <td>
                            Simple patterns optionally start or end with a star character (
                            <code>*</code>). For instance: <code>/about/company.html</code> matches
                            exactly this URL, <code>about/*</code> matches any URL that starts with
                            <code>about/</code>, <code>*.gif</code> matches any URL that ends with
                            <code>.gif</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>Custom Pattern</td>
                        <td>
                            In this case, an additional <code>matcher</code> attribute must be
                            specified on the <code>&lt;page&gt;</code> element. The
                            <code>matcher</code> argument points to a matcher processor qualified
                            name. Two matcher processors are provided with OPS: the Perl5 matcher
                            (<code>oxf:perl5-matcher</code>) and the Glob matcher
                            (<code>oxf:glob-matcher</code>). The Perl5 matcher accepts <link
                            href="http://www.perl.com/doc/manual/html/pod/perlre.html">Perl regular
                            expressions</link> and the Glob matcher accepts <link
                            href="http://jakarta.apache.org/oro/api/org/apache/oro/text/GlobCompiler.html">Unix
                            shell glob expressions</link>.
                        </td>
                    </tr>
                </table>
                <p>
                    This is an example of <code>&lt;files&gt;</code> element using the Perl5
                    matcher:
                </p>
                <xml-source>
                    <files path-info="/doc/[^.]*\.html" matcher="oxf:perl5-matcher"/>
                </xml-source>
                <p>
                    As with the <code>&lt;files&gt;</code> element, a matcher can also be specified
                    on a <code>&lt;page&gt;</code> element. When using a matcher that allows for
                    groups, the part of the path matched by those groups can be extracted as
                    documented above with the <code>&lt;setvalue&gt;</code> element. Note that the
                    only matcher bundled with OPS that accepts groups is the Perl5 matcher.
                </p>
            </section>
            <a name="epilogue-element"/>
            <section>
                <title>The epilogue Element</title>
                <img print-format="pdf" src="pages/reference-controller-epilogue.png"/>
                <p>
                    You often want a common look and feel across pages. Instead of duplicating the
                    code implementing this look and feel in every page view, you can define it in a
                    central location called the <i>page flow epilogue</i>. The
                    <code>&lt;epilogue&gt;</code> element specifies the <a
                    href="reference-xpl-pipelines">XPL pipeline</a> which implements the page flow
                    epilogue.
                </p>
                <p>
                    This is an example of <code>&lt;epilogue&gt;</code> element, pointing to the
                    default epilogue XPL pipeline:
                </p>
                <xml-source>
                    <epilogue url="oxf:/config/epilogue.xpl"/>
                </xml-source>
                <p>
                    The page flow epilogue is discussed in more details in the <a
                    href="reference-epilogue">Page Flow Epilogue</a> documentation.
                </p>
            </section>
            <a name="not-found-handler"/>
            <section>
                <title>The not-found-handler Element</title>
                <p>
                    The <code>&lt;not-found-handler&gt;</code> element is used to specify the
                    identifier of a page to call when no <code>&lt;page&gt;</code> element in the
                    page flow is matched by the current request. There can be only one
                    <code>&lt;not-found-handler&gt;</code> per page flow.
                </p>
                <p>
                    This is an example of <code>&lt;not-found-handler&gt;</code> element and the
                    associated <code>&lt;page&gt;</code> element:
                </p>
                <xml-source>
                    <comment> "Not Found" page displayed when no page matches the request URL </comment>
                    <page id="not-found" path-info="/not-found" view="/config/not-found.xml"/>
                    <not-found-handler page="not-found"/>
                </xml-source>
                <p>
                    By default, <code>oxf:/config/not-found.xml</code> displays a simple XHTML page
                    telling the user that the page requested cannot be found.
                </p>
                <note>
                    <p>
                        The <code>&lt;not-found-handler&gt;</code> element is not used for resources
                        served through the <code>&lt;files&gt;</code> element. In that case, the
                        PFC returns instead a "not found" code to the user agent (code 404 in the
                        case of HTTP).
                    </p>
                </note>
            </section>
        </section>
        <a name="error-handling"/>
        <section>
            <title>Error Handling</title>
            <p>
                Several things can go wrong during the execution of a page flow by the PFC, in
                particular:
            </p>
            <ul>
                <li>
                    <p>
                        The page flow may be ill-formed.
                    </p>
                </li>
                <li>
                    <p>
                        A runtime error may be encountered when processing the page flow, such as
                        not finding a particular page model referenced by a page.
                    </p>
                </li>
                <li>
                    <p>
                        An action, page model, page view or epilogue may generate an error at
                        runtime.
                    </p>
                </li>
            </ul>
            <p>
                Those error conditions are not directly handled by the PFC. Instead, they are
                handled with the error <a href="reference-xpl-pipelines">XPL pipeline</a> specified
                in the web application's <code>web.xml</code> file. By default, the error processor
                is the Pipeline processor, which runs the <code>oxf:/config/error.xpl</code> XPL
                pipeline. You can configure <code>error.xpl</code> for your own needs. By default,
                it formats and displays the Java exception which caused ther error.
            </p>
            <p>
                See <a href="integration-packaging">Packaging and Deployment</a> for more
                information about configuring error processors.
            </p>
        </section>
        <a name="combinations"/>
        <section>
            <title>Typical Combinations of Page Model and Page View</title>
            <p>
                The sections below show how page model and page view are often combined.
            </p>
            <section>
                <title>View Only</title>
                <p>
                    Simple pages with no back-end code can be implemented with a single <a
                    href="reference-xpl-pipelines">XPL pipeline</a>, XSLT template or static page.
                    A view XPL pipeline must have a <code>data</code> output. The XML generated by
                    the view then goes to the epilogue.

                    <img print-format="pdf" src="pages/reference-controller-view.png"/>
                </p>
            </section>
            <section>
                <title>Model Only</title>
                <p>
                    If a page is not sent back to the user agent, there is no need for a view. This
                    is typically the case when a redirect needs to be issued, a binary file is
                    produced, or when a page simply implements an XML service.

                    <img print-format="pdf" src="pages/reference-controller-model.png"/>
                </p>
            </section>
            <section>
                <title>View Only with XML Submission</title>
                <p>
                    This is a variant of the <i>view only</i> scenario, where an XML submission is
                    used. In this case, the view receives the XML submission as the
                    <code>instance</code> input.

                    <img print-format="pdf" src="pages/reference-controller-view-xforms.png"/>
                </p>
            </section>
            <section>
                <title>Model Only with XML Submission</title>
                <p>
                    This is a variant of the <i>model only</i> scenario, where an XML submission is
                    used.

                    <img print-format="pdf" src="pages/reference-controller-model-xforms.png"/>
                </p>
            </section>
            <section>
                <title>View and Model</title>
                <p>
                    This is the classic case. An XPL pipeline implements the page model and an XSLT
                    template implements the page view where data produced by the model is consumed
                    by the view.

                    <img print-format="pdf" src="pages/reference-controller-view-model.png"/>
                </p>
            </section>
            <section>
                <title>View and Model with XML Submission, Case 1</title>
                <p>
                    This is the equivalent of the previous model where an XML submission is used. In
                    this case an <code>instance</code> input is made available to the model and the
                    view.

                    <img print-format="pdf" src="pages/reference-controller-view-model-xforms-1.png"/>
                </p>
            </section>
            <section>
                <title>View and Model with XML Submission, Case 2</title>
                <p>
                    This is a variant of the previous case where the model declares an
                    <code>instance</code> output. This allows the model to modify the submitted XML
                    instance. This is typically useful when the view displays some values from the
                    XML submission document but these values are not exactly the same as those
                    entered by the user. For example, a page with a text field where the user types
                    an airport code. If the user enters a known city such as San Francisco, the
                    application may automatically add the corresponding airport code (SFO in this
                    case).

                    <img print-format="pdf" src="pages/reference-controller-view-model-xforms-2.png"/>
                </p>
            </section>
        </section>
        <section>
            <title>Examples</title>
            <section>
                <title>Redirection With the PFC</title>
                <p>
                    The following example illustrates how to perform a simple redirection with the PFC.
                    Assume you want some path, <code>/a</code>, to be redirect to another path,
                    <code>/b</code>. You can do this as follows:
                </p>
                <xml-source>
                    <page path-info="/a">
                        <action>
                            <result page="page-b" instance-passing="redirect"/>
                        </action>
                    </page>
                    <page id="page-b" path-info="/b">
                        ...
                    </page>
                </xml-source>
                <p>
                    Note that you do not have to use <code>redirect</code>, but that doing so will cause
                    the user agent to display the path to page <code>/b</code> in its URL bar. The
                    <code>instance-passing</code> attribute is also unnecessary if
                    <code>redirect</code> is already the default instance passing mode.
                </p>
            </section>
            <section>
                <title>Implementing XML Services With the PFC</title>
                <p>
                    The PFC allows you to very easily receive an XML document submitted, for
                    example with an HTTP POST, and to generate an XML response. This can be useful
                    to implement XML services such as XML-RPC, SOAP, or any XML-over-HTTP service.
                    The following PFC configuration defines a simple XML service:
                </p>
                <xml-source>
                    <page path-info="/xmlrpc" model="xml-rpc.xpl"/>
                </xml-source>
                <p>
                    Notice that there is no <code>view</code> attribute: all the processing for this
                    page is done in the page model.
                </p>
                <p>
                    The following content for <code>xml-rpc.xpl</code> implements an XML service
                    returning as a response the POST-ed XML document:
                </p>
                <xml-source>
                    <p:config xmlns:p="http://www.orbeon.com/oxf/pipeline"
                        xmlns:oxf="http://www.orbeon.com/oxf/processors">

                        <comment> The XML submission is available on the "instance" input </comment>
                        <p:param name="instance" type="input" schema-href="request.rng"/>

                        <comment> Processing of the XML submission (here we just return the request) </comment>
                        <p:processor name="oxf:identity">
                            <p:input name="data" href="#instance"/>
                            <p:output name="data" id="response"/>
                        </p:processor>

                        <comment> Generate a response </comment>
                        <p:processor name="oxf:xml-serializer">
                            <p:input name="data" href="#response" schema-href="response.rng"/>
                            <p:input name="config">
                                <config/>
                            </p:input>
                        </p:processor>
                    </p:config>
                </xml-source>
                <p>
                    Notice the optional <code>schema-href</code> attributes which allow validating
                    the request and the response against schemas.
                </p>
            </section>
        </section>
        <!--
        <section>
            <title>Differences with OPS 2.8</title>
            <p>
                TODO
            </p>
        </section>
        -->
    </body>
</document>
