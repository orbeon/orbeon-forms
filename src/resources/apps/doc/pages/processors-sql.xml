<!--
    Copyright (C) 2004 Orbeon, Inc.

    The Orbeon documentation is not distributed under the LGPL license. Use of the documentation is
    subject to the following terms:

    * Conversion to other formats is allowed, but the actual content may not be altered or edited
      in any way.

    * You may create printed copies for your own personal use.

    * For all other uses, such as selling printed copies or using (parts of) the manual in another
      publication, prior written agreement from Orbeon, Inc. is required.

    Please contact Orbeon at info@orbeon.com for more information.
-->
<document xmlns:p="http://www.orbeon.com/oxf/pipeline"
          xmlns:xforms="http://www.w3.org/2002/xforms"
          xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <header>
        <title>SQL Processor</title>
    </header>
    <body>
        <section>
            <title>Introduction</title>
            <p>
                The SQL processor provides an XML interface to any SQL database accessible through
                JDBC. It allows to easily query databases and produce XML outputs readily usable by
                other processors. Conversely, the SQL processor allows to perform updates,
                insertions and deletions from XML data generated by other processors.
            </p>
        </section>
        <section>
            <title>Inputs and Outputs</title>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Mandatory</th>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>config</code></td>
                    <td>Configuration template</td>
                    <td align="center">Yes</td>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>data</code></td>
                    <td>Source XML data</td>
                    <td align="center">No</td>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>datasource</code></td>
                    <td>Datasource configuration</td>
                    <td align="center">No</td>
                </tr>
                <tr>
                    <td align="center">Output</td>
                    <td><code>data</code></td>
                    <td>Result XML data</td>
                    <td align="center">No</td>
                </tr>
            </table>
            <p>
                If the <code>data</code> input is not connected, the SQL processor configuration
                must not use XPath expressions operating on it. If this condition is not satisfied,
                the SQL processor generates an error at runtime. It is typically useful to omit the
                <code>data</code> input when the SQL processor only reads data from the database and
                generates an output XML document.
            </p>
            <p>
                If the <code>data</code> output is not connected, the output of the SQL processor is
                simply ignored. It is typically useful to omit the <code>data</code> output when
                the SQL processor only updates or insert data into the database from an input XML
                document.
            </p>
        </section>
        <section>
            <title>Configuration Template</title>
            <section>
                <title>Configuration</title>
                <p>
                    The configuration template features a simple set of XML tags that allow you to
                    integrate SQL queries and XML. The tags live in the
                    <code>http://orbeon.org/oxf/xml/sql</code> namespace, which is usually mapped to
                    the <code>sql</code> prefix. An configuration input has the following format:
                </p>
                <xml-source>
<sql:config>
    <comment>Optional user content</comment>
    <sql:connection>
        <comment> Datasource name (can also be specified with optional "datasource" input) </comment>
        <sql:datasource>my-datasource</sql:datasource>
        <comment>...</comment>
    </sql:connection>
    <comment>Optional user content</comment>
</sql:config>
                </xml-source>
                <p>
                    The <code>sql:datasource</code> element specifies a datasource name under
                    <code>java:comp/env/jdbc</code>. In the example above, the datasource named
                    <code>my-datasource</code> is used. How the datasource is configured depends on
                    the application server used. Please refer to the documentation of your
                    application server for more information.
                </p>
                <p>
                    Alternatively, the <code>sql:datasource</code> element can be omitted. In that
                    case, the <code>datasource</code> input of the SQL processor must be connected
                    to an external datasource definition, which describes database connections
                    without using JNDI names mapped by the container. This is an example of
                    datasource definition:
                </p>
                <xml-source>
                    <datasource>
                        <comment> Specify the driver for the database </comment>
                        <driver-class-name>org.hsqldb.jdbcDriver</driver-class-name>
                        <comment> This causes the use of the embedded database </comment>
                        <uri>jdbc:hsqldb:file:orbeondb</uri>
                        <comment> Optional username and password </comment>
                        <username>sa</username>
                        <password></password>
                    </datasource>
                </xml-source>
                <warning>
                    <p>
                        External datasource definitions do not use connection pooling at the
                        moment. Because creating database connections is usually an expensive
                        operation, they should be used only for development or demo purposes.
                    </p>
                </warning>
                <p>
                    The <code>sql:config</code> element can contain any number of user-defined
                    content before and after the <code>sql:connection</code> element.
                </p>
            </section>
            <section>
                <title>Root Element</title>
                <p>
                    It is important to make sure that one and exactly one root element is output by
                    the SQL processor. A good place to put such a root element is around the
                    <code>sql:connection</code> element:
                </p>
                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <employees>
        <sql:connection>
            <comment>...</comment>
        </sql:connection>
    </employees>
</sql:config>
                </xml-source>
            </section>
            <section>
                <title>sql:execute</title>
                <p>
                    The <code>sql:execute</code> element controls the execution of a single SQL
                    query, call or update (SQL <code>update</code>, <code>insert</code> or
                    <code>delete</code>). It must start with either a <code>sql:query</code>, a
                    <code>sql:call</code> or a <code>sql:update</code> element, which contains the
                    SQL to execute. <code>sql:query</code> and <code>sql:call</code> can be followed
                    by zero or more <code>sql:result-set</code> elements and an optional
                    <code>sql:no-results</code> element. Any number of <code>sql:execute</code>
                    elements can be used under a <code>sql:connection</code> element, in order to
                    execute several queries or updates within a single connection declaration.
                </p>
                <xml-source>
<comment>Optional user content</comment>
<sql:execute>
    <sql:query>
        <comment>...</comment>
    </sql:query>
    <comment>Optional user content</comment>
    <sql:result-set>
        <comment>...</comment>
    </sql:result-set>
    <sql:no-results>
        <comment>...</comment>
    </sql:no-results>
</sql:execute>
<comment>Optional user content</comment>
<sql:execute>
    <sql:call>
        <comment>...</comment>
    </sql:call>
    <comment>Optional user content</comment>
    <sql:result-set>
        <comment>...</comment>
    </sql:result-set>
    <sql:no-results>
        <comment>...</comment>
    </sql:no-results>
</sql:execute>
<comment>Optional user content</comment>
<sql:execute>
    <sql:update>
        <comment>...</comment>
    </sql:update>
</sql:execute>
<comment>Optional user content</comment>
                </xml-source>
            </section>

            <section>
                <title>sql:query and sql:update</title>
                <p>
                    <code>sql:query</code> and <code>sql:update</code> encapsulate SQL statements.
                    Like with JDBC, a distinction is made between queries (SQL
                    <code>select</code>) and updates (SQL <code>update</code>, <code>insert</code>
                    and <code>delete</code>):
                </p>
                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
  select * from employee
</sql:query>
                </xml-source>
                <xml-source>
<sql:update xmlns:sql="http://orbeon.org/oxf/xml/sql">
  insert into employees values ('John', 'Doe')
</sql:update>
                </xml-source>

                <p>
                    It is possible to pass parameters to a query using the <code>sql:param</code>
                    element. <code>sql:param</code> requires a <code>type</code> attribute that
                    specifies the type of the parameter to set. The type system is borrowed from the
                    <a href="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes</a>
                    specification. The following types are supported:
                </p>

                <ul>
                    <li><code>xs:string</code></li>
                    <li><code>xs:int</code></li>
                    <li><code>xs:boolean</code></li>
                    <li><code>xs:decimal</code></li>
                    <li><code>xs:float</code></li>
                    <li><code>xs:double</code></li>
                    <li><code>xs:dateTime</code></li>
                    <li><code>xs:date</code></li>
                    <li><code>xs:base64Binary</code></li>
                    <li><code>oxf:xmlFragment</code></li>
                </ul>
                <note>
                    <p>
                        By default, the <code>xs</code> and <code>oxf</code> prefixes must be
                        declared, as is customary in XML. For backward compatiblity with versions of
                        OPS where the prefixes did not have to be declared, set the
                        <code>legacy-implicit-prefixes</code> property as follows:
                    </p>
                    <xml-source>
                        <property as="xs:boolean" processor-name="oxf:sql" name="legacy-implicit-prefixes" value="true"/>
                    </xml-source>
                    <p>
                        When this property is missing or set to <code>false</code>, type prefixes
                        must be mapped as is customary for XML vocabularies. Add the following
                        namespace declarations:
                        <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> and
                        <code>xmlns:odt="http://orbeon.org/oxf/xml/datatypes"</code>. Doing so then
                        allows using data types as before, for example <code>xs:string</code> or
                        <code>odt:xmlFragment</code>.
                    </p>
                </note>
                <p>
                    <code>xs:date</code> and <code>xs:dateTime</code> should be
                    in one of the following formats:
                </p>
                <ul>
                    <li><code>CCYY-MM-DDThh:mm:ss.sss</code></li>
                    <li><code>CCYY-MM-DDThh:mm:ss</code></li>
                    <li><code>CCYY-MM-DD</code></li>
                </ul>
                <p>
                    Unless a getter is nested in the <code>sql:param</code> element (see the section
                    about nested queries below), a <code>select</code> attribute is mandatory. Its
                    content is evaluated as an XPath expression against the input XML document:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
select first_name, last_name
  from employee
 where employee_id in (<sql:param type="xs:int" select="/query/employee-id[1]"/>,
                       <sql:param type="xs:int" select="/query/employee-id[2]"/>)
</sql:query>
                </xml-source>

                <p>Any number of <code>sql:param</code> elements may be used.</p>

                <p>
                    <code>sql:param</code> supports an optional boolean <code>replace</code>
                    attribute, that can take the value <code>true</code> or <code>false</code> (the
                    default). When <code>replace</code> is set to <code>true</code>, the parameter
                    is simply replaced in the query, instead of being set on a JDBC
                    <code>PreparedStatement</code>. This however works only with the
                    <code>xs:int</code> and <code>oxf:literalString</code> types. This attribute is
                    useful to dynamically generate parts of SQL queries, or to set parameters that
                    do not allow being set via JDBC's <code>setYyy</code> methods. For example,
                    with SQL Server:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
    select top&#160;<sql:param type="xs:int" select="/query/max-rows" replace="true"/>&#160;*
      from employee
</sql:query>
                </xml-source>

                <p>
                    <code>sql:param</code> supports an optional <code>separator</code> attribute.
                    When that attribute is present, the result of the XPath expression in the
                    <code>select</code> attribute is interpreted as a node-set. One query parameter
                    is set for each element in the node set, separated by the characters in the
                    separator. For example:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
   select * from book
    where book_id in (<sql:param type="xs:int" select="/query/book-id" separator=","/>)
</sql:query>
                </xml-source>

                <p>
                    Assuming the input document contains:
                </p>

                <xml-source>
<query>
    <book-id>5</book-id>
    <book-id>7</book-id>
    <book-id>11</book-id>
    <book-id>13</book-id>
</query>
                </xml-source>

                <p>
                    The following equivalent query will be executed:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
   select * from book
    where book_id in (5, 7, 11, 13)
</sql:query>
                </xml-source>
            </section>
            <section>
                <title>Calling Stored Procedure With sql:call</title>
                <p>
                    The <code>sql:call</code> element allows for calling stored procedures using the
                    JDBC escape syntax. <code>sql:call</code> uses the JDBC
                    <code>CallableStatement</code> interface. The following example calls a
                    procedure called <code>SalesByCategory</code> with two parameters:
                </p>
                <xml-source>
                    <sql:call>
                        { call SalesByCategory(<sql:param type="xs:string" select="/*/category"/>,
                                               <sql:param type="xs:int" select="/*/year"/>) }
                    </sql:call>
                </xml-source>
                <p>
                    The brackets ("<code>{</code>" and "<code>}</code>") and the keyword
                    <code>call</code> are part of the JDBC escape syntax which allows calling
                    stored procedures without using a proprietary syntax.
                </p>
                <note>
                    <code>OUT</code> and <code>INOUT</code> parameters are not yet supported.
                </note>
            </section>
            <section>
                <title>Handling Result-Sets With sql:result-set and sql:no-results</title>
                <p>
                    These elements must be used only in conjunction with <code>sql:query</code> or
                    <code>sql:call</code>.
                </p>
                <p>
                    A query or call may return multiple result-sets. It is possible to handle the
                    result-sets returned by a query or call individually for each result-set, or
                    globally for all result-sets, using the <code>sql:result-set</code> element. The
                    optional <code>result-sets</code> attribute specifies how many result-sets are
                    handled by a given <code>sql:result-set</code> element. If not specified, the
                    default is one result-set. If the value is <code>unbounded</code>, the
                    <code>sql:result-set</code> element handles all the remaining result-sets
                    returned by the statement execution. Otherwise, a positive number of result-sets
                    must be specified. For example:
                </p>
                <xml-source>
                    <comment>Handle the first two result-sets</comment>
                    <sql:result-set result-sets="2">
                        <my-first-result-sets>
                            <sql:row-iterator>
                                <row>
                                    <sql:get-columns format="xml"/>
                                </row>
                            </sql:row-iterator>
                        </my-first-result-sets>
                    </sql:result-set>
                    <comment>Handle All the remaining result-sets</comment>
                    <sql:result-set result-sets="unbounded">
                        <my-other-result-sets>
                            <sql:row-iterator>
                                <row>
                                    <sql:get-columns format="xml"/>
                                </row>
                            </sql:row-iterator>
                        </my-other-result-sets>
                    </sql:result-set>
                    <comment>This will be executed if no row was returned by any result-set</comment>
                    <sql:no-results>
                        <there-are-no-results/>
                    </sql:no-results>
                </xml-source>
                <note>
                    The body of the <code>sql:result-set</code> element is not executed if the
                    result-set does not contain at least one row.
                </note>
                <p>
                    If a <code>sql:no-results</code> element is present after the
                    <code>sql:result-sets</code> elements, its template content executes only if
                    none of the previous <code>sql:result-set</code> elements has returned rows.
                    <code>sql:no-results</code> may contain user-defined elements and nested queries
                    (see below).
                </p>
                <p>
                    <code>sql:result-set</code> may contain a <code>sql:row-iterator</code> element,
                    which is evaluated once for every row of the result set.
                    <code>sql:row-iterator</code> typically contains user-defined content, as well
                    as column getters such as <code>sql:get-column-value</code> and
                    <code>sql:get-columns</code>.
                </p>
                <xml-source>
                    <sql:result-set xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:row-iterator>
                            <employee>
                                <first-name><sql:get-column-value type="xs:string" column="first_name"/></first-name>
                                <last-name><sql:get-column-value type="xs:string" column="last_name"/></last-name>
                            </employee>
                        </sql:row-iterator>
                    </sql:result-set>
                </xml-source>
                <p>
                    Assuming the result set contains two rows with "John Doe" and "Billy Smith",
                    the above code produces the following XML fragment:
                </p>
                 <xml-source>
                    <employee>
                        <first-name>John</first-name>
                        <last-name>Doe</last-name>
                    </employee>
                    <employee>
                        <first-name>Billy</first-name>
                        <last-name>Smith</last-name>
                    </employee>
                </xml-source>
            </section>
            <section>
                <title>Getting Column Values</title>
                <section>
                    <title>Retrieving Single Columns</title>
                    <p>
                        <code>sql:get-column-value</code> takes a mandatory <code>column-name</code>
                        attribute and an optional <code>type</code> attribute. If specified, the
                        attribute must be compatible with the SQL type of the column being read. The
                        type system is borrowed from the <a href="http://www.w3.org/TR/xmlschema-2/">XML
                        Schema Part 2: Datatypes</a> specification. The following types are supported:
                    </p>
                    <ul>
                        <li><code>xs:string</code></li>
                        <li><code>xs:int</code></li>
                        <li><code>xs:boolean</code></li>
                        <li><code>xs:decimal</code></li>
                        <li><code>xs:float</code></li>
                        <li><code>xs:double</code></li>
                        <li><code>xs:dateTime</code></li>
                        <li><code>xs:date</code></li>
                        <li><code>xs:base64Binary</code></li>
                        <li><code>oxf:xmlFragment</code></li>
                    </ul>
                    <note>
                        The same remark applies to types used on <code>sql:param</code>: the prefixes
                        must be declared unless the <code>legacy-implicit-prefixes</code> specifies
                        otherwise.
                    </note>
                    <p>
                        <code>xs:dateTime</code> returns a date in the following format:
                        <code>CCYY-MM-DDThh:mm:ss.sss</code>.
                    </p>
                    <p>
                        <code>xs:date</code> returns a date in the following format:
                        <code>CCYY-MM-DD</code>.
                    </p>
                    <p>
                        <code>oxf:xmlFragment</code> is a special type that gets the column as a
                        string, parses it as an XML fragment, and embeds the resulting XML in the SQL
                        processor output.
                    </p>
                    <note>
                        <p>
                            For compatibility with XPath 1.0, <code>xs:float</code> and
                            <code>xs:double</code> do not return values in the exponential notation.
                            For example, instead of <code>1.2E10</code>, <code>12000000000</code> is
                            returned.
                        </p>
                    </note>
                </section>
                <section>
                    <title>Retrieving Multiple Columns</title>
                    <p>
                        When the number of columns returned is large, it is convenient to use
                        <code>sql:get-columns</code>, which automatically determines what columns are
                        available and generates elements accordingly. <code>sql:get-columns</code> takes
                        an optional <code>prefix</code> attribute specifying the output namespace prefix
                        to use for all the elements, and an optional <code>format</code> attribute
                        specifying how column names are converted. It also supports any number of
                        embedded <code>exclude</code> elements that specify columns to exclude from the
                        result.
                    </p>
                    <p>
                        <code>sql:get-columns</code> supports an <code>all-elements</code> attribute.
                        If set to <code>true</code>, an element is output for a column even if that
                        column returns a null value. If missing or set to <code>false</code>, no element
                        is output for a null column.
                    </p>
                    <p>
                        The namespace prefix, if specified, must have been mapped to a namespace URI.
                    </p>
                    <p>
                        If no format is specified, the original column names are used. Specifying the
                        <code>xml</code> format converts all column names to lower case and transforms
                        "_" into "-".
                    </p>
                    <p>
                        This example:
                    </p>
                    <xml-source>
                        <sql:result-set xmlns:sql="http://orbeon.org/oxf/xml/sql">
                            <sql:row-iterator>
                                <employee>
                                    <sql:get-columns format="xml"/>
                                </employee>
                            </sql:row-iterator>
                        </sql:result-set>
                    </xml-source>
                    <p>
                        Produces these results:
                    </p>
                    <xml-source>
                        <employee>
                            <first-name>John</first-name>
                            <last-name>Doe</last-name>
                        </employee>
                        <employee>
                            <first-name>Billy</first-name>
                            <last-name>Smith</last-name>
                        </employee>
                    </xml-source>
                    <p>
                        Not specifying the <code>xml</code> format generates the
                        following results:
                    </p>
                    <xml-source>
                        <employee>
                            <first_name>John</first_name>
                            <last_name>Doe</last_name>
                        </employee>
                        <employee>
                            <first_name>Billy</first_name>
                            <last_name>Smith</last_name>
                        </employee>
                    </xml-source>
                    <p>
                        It is possible to exclude the <code>first_name</code> column
                        as follows:
                    </p>
                    <xml-source>
                        <sql:result-set xmlns:sql="http://orbeon.org/oxf/xml/sql">
                            <sql:row-iterator>
                                <employee>
                                    <sql:get-columns format="xml">
                                        <sql:exclude>first_name</sql:exclude>
                                    </sql:get-columns>
                                </employee>
                            </sql:row-iterator>
                        </sql:result-set>
                    </xml-source>
                    <p>
                        This generates the following results:
                    </p>
                    <xml-source>
                        <employee>
                            <last_name>Doe</last_name>
                        </employee>
                        <employee>
                            <last_name>Smith</last_name>
                        </employee>
                    </xml-source>
                </section>
                <section>
                    <title>Result-Set Metadata</title>
                    <p>
                        It is possible to retrieve result-set metadata. The following elements must
                        be used within a <code>sql:column-iterator</code> element, unless a
                        <code>column-name</code> or <code>column-index</code> attribute is
                        explicitly specified:
                    </p>
                    <ul>
                        <li>
                            <code>sql:get-column-index</code>: retrieves the current column index.
                        </li>
                        <li>
                            <code>sql:get-column-name</code>: retrieves the current column name.
                        </li>
                        <li>
                            <code>sql:get-column-type</code>: retrieves the current column type name
                            as returned by result-set metadata.
                        </li>
                    </ul>
                </section>
            </section>
            <section>
                <title>Outputting Attributes With sql:attribute</title>
                <p>
                    It is possible to dynamically generate new attributes with the
                    <code>sql:attribute</code> element:
                </p>
                <xml-source>
                    <my-element>
                        <sql:attribute name="index">
                            <sql:get-column-index/>
                        </sql:attribute>
                        ...
                    </my-element>
                </xml-source>
                <p>
                    This will result in something like:
                </p>
                <xml-source>
                    <my-element index="3">
                        ...
                    </my-element>
                </xml-source>
            </section>
            <section>
                <title>Iterating Over Result-Set Columns With sql:column-iterator</title>
                <p>
                    You can explicitly iterate over all the columns returned by a result-set with
                    the <code>sql:column-iterator</code> element. A column iterator can be used
                    under the <code>sql:result-set</code> element, or under the
                    <code>sql:row-iterator</code> element. This allows for example easily extracting
                    column metadata:
                </p>
                <xml-source>
                    <sql:result-set>
                        <metadata>
                            <sql:column-iterator>
                                <column>
                                    <sql:attribute name="index">
                                        <sql:get-column-index/>
                                    </sql:attribute>
                                    <sql:attribute name="name">
                                        <sql:get-column-name/>
                                    </sql:attribute>
                                    <sql:attribute name="type">
                                        <sql:get-column-type/>
                                    </sql:attribute>
                                    <index><sql:get-column-index/></index>
                                    <name><sql:get-column-name/></name>
                                    <type><sql:get-column-type/></type>
                                </column>
                            </sql:column-iterator>
                        </metadata>
                    </sql:result-set>
                </xml-source>
            </section>
            <section>
                <title>Reading and Writing XML Documents</title>
                <p>
                    As explained in the section about <code>sql-type</code> above, when text data,
                    in particular XML data, is large, it is best stored as a CLOB type or, in the
                    case of XML, as a native database XML data type such as the Oracle
                    <code>XMLType</code> data type.
                </p>
                <p>
                    Reading and writing XML data is supported to and from database CLOBs and, with
                    Oracle 9, to and from <code>XMLType</code>. The <code>oxf:xmlFragment</code>
                    type must be used. To write XML data to a CLOB, use the
                    <code>oxf:xmlFragment</code> type as follows:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_clob_table (clob_column)
                            values (<sql:param select="/*" type="oxf:xmlFragment" sql-type="clob"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <p>
                    The XPath expression must return one element node. The result of the XPath
                    expression specified in the <code>select</code> attribute is converted into a
                    new XML document having as root element the selected element node. The document
                    is then serialized to a character stream and stored as a CLOB.
                </p>
                <p>
                    To read a document from a CLOB column, use the <code>oxf:xmlFragment</code>
                    type as follows:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:query>
                            select clob_column from test_clob_table
                        </sql:query>
                        <sql:result-set>
                            <rows>
                                <sql:row-iterator>
                                    <row>
                                        <sql:get-column-value type="oxf:xmlFragment" column="clob_column"/>
                                    </row>
                                </sql:row-iterator>
                            </rows>
                        </sql:result-set>
                    </sql:execute>
                </xml-source>
                <p>
                    For each row returned, the character data stored in the CLOB column is read as
                    text and parsed into an XML fragment. The fragment must be well-formed,
                    otherwise an exception is thrown. The resulting fragment is then embedded into
                    the SQL processor output.
                </p>
                <p>
                    With Oracle 9, it is also possible to write to the native Oracle
                    <code>XMLType</code> data type:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_xmltype_table (xmltype_column)
                            values (<sql:param select="/*" type="oxf:xmlFragment" sql-type="xmltype"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <note>
                    <p>
                        The benefit of using the Oracle <code>XMLType</code> data type is that XML
                        is stored in a structured way in the database. This allows creating indexes
                        on XML data, doing partial document updates, etc. This however requires
                        creating an XML schema. For more information, please refer to the <a
                        href="http://download-west.oracle.com/docs/cd/B10501_01/appdev.920/a96620/toc.htm">Oracle
                        XML DB Developer's Guide</a>.
                    </p>
                </note>
                <p>
                    Reading from an <code>XMLType</code> column is done the same way as with a CLOB
                    column:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:query>
                            select xmltype_column from test_xmltype_table
                        </sql:query>
                        <sql:result-set>
                            <rows>
                                <sql:row-iterator>
                                    <row>
                                        <sql:get-column-value type="oxf:xmlFragment" column="xmltype_column"/>
                                    </row>
                                </sql:row-iterator>
                            </rows>
                        </sql:result-set>
                    </sql:execute>
                </xml-source>
                <warning>
                    <p>
                        Writing to CLOB columns, as well as writing and reading to and from
                        <code>XMLType</code> columns, is currently only supported with the following
                        application server / database combinations:
                    </p>
                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>
                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from CLOB columns on the other hand is supported with all JDBC
                        drivers that support the CLOB API.
                    </p>
                </warning>
            </section>
            <section>
                <title>Specifying a SQL Type</title>
                <p>
                    When setting a parameter of type <code>xs:string</code> or
                    <code>oxf:xmlFragment</code>, it is possible to specify an additional attribute
                    on <code>sql:param</code>: <code>sql-type</code>. By default, text is written
                    using the JDBC setString() method. In case the data must be stored in the
                    database as a Character Large OBject (CLOB) or other database-specific types,
                    it is necessary to tell OPS that a different API must be used. For example, to
                    write a string into a CLOB:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_clob_table (clob_column)
                            values (<sql:param select="/document/text" type="xs:string" sql-type="clob"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <p>
                    The same string can be written as a regular <code>varchar</code> type as
                    follows:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_table (varchar_column)
                            values (<sql:param select="/document/text" type="xs:string" sql-type="varchar"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <p>
                    <code>varchar</code> is actually the default, so you can simply omit the
                    <code>sql-type</code> and write:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_table (varchar_column)
                            values (<sql:param select="/document/text" type="xs:string"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <note>
                    <p>
                        The disadvantage of using database columns of type <code>varchar</code> is
                        that those are severely limited in size, for example 4000 bytes in the case
                        of Oracle 9. The maximum size of CLOB columns is usually much larger, for
                        example up to 4 GB with Oracle 9. In order to store large strings or large
                        XML documents, it is therefore necessary to use the CLOB type.
                    </p>
                </note>
                <p>
                    The following values are supported for <code>sql-type</code>:
                </p>
                <ul>
                    <li><code>varchar</code> (the default)</li>
                    <li><code>clob</code></li>
                    <li><code>xmltype</code> (see Reading and Writing XML Documents below)</li>
                </ul>
                <warning>
                    <p>
                        Using the <code>clob</code> and <code>xmltype</code> SQL types is currently
                        only supported with the following application server / database
                        combinations:
                    </p>
                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>
                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from CLOB columns on the other hand is supported with all JDBC
                        drivers that support the CLOB API.
                    </p>
                </warning>
            </section>
            <a name="binary-data"/>
            <section>
                <title>Reading and Writing Binary Data</title>
                <p>
                    Reading and writing binary data is supported to and from database Binary Large
                    OBjects (BLOBs) as well as binary types (<code>BINARY</code>, <code>VARBINARY
                    </code>and <code>LONGVARBINARY</code> SQL types). The
                    <code>xs:base64Binary</code> type (read and write) or the <code>xs:anyURI</code>
                    type (write only) must be used. To write to a BLOB, use the
                    <code>xs:base64Binary</code> type as follows:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_blob_table (blob_column)
                            values (<sql:param select="/*" type="xs:base64Binary"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <p>
                    The result of the XPath expression specified in the <code>select</code>
                    attribute is converted into a character string, following the XPath semantics.
                    That string is then interpreted as Base64-encoded data, before being written to
                    the BLOB column. For example, the following input document:
                </p>
                <xml-source>
<root>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
</root>
                </xml-source>
                <p>
                    Is converted to the following string when the expression <code>/*</code> is
                    applied:
                </p>
                <code>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
                </code>
                <p>
                    With <code>xs:anyURI</code>, the result of the XPath expression is converted
                    into a string and interpreted as a URL. The URL is read, and the resulting data
                    is stored into the BLOB column. For example:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:update>
                            insert into test_blob_table (blob_column)
                            values (<sql:param select="/my/uri" type="xs:anyURI"/>)
                        </sql:update>
                    </sql:execute>
                </xml-source>
                <note>
                    <p>
                        XForms file uploads typically generate URLs in XForms instances if the type
                        chosen for the uploaded file in the XForms model is <code>xs:anyURI</code>.
                        The advantage of using <code>xs:anyURI</code> is that large resources do not
                        have to reside entirely in memory.
                    </p>
                </note>
                <p>
                    To read a BLOB or BINARY column, use the <code>xs:base64Binary</code> type as
                    follows:
                </p>
                <xml-source>
                    <sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:query>
                            select blob_column from test_blob_table
                        </sql:query>
                        <sql:result-set>
                            <rows>
                                <sql:row-iterator>
                                    <row>
                                        <sql:get-column-value type="xs:base64Binary" column="blob_column"/>
                                    </row>
                                </sql:row-iterator>
                            </rows>
                        </sql:result-set>
                    </sql:execute>
                </xml-source>
                <p>
                    This will produce the following result if the document above was written to the
                    database first:
                </p>
                <xml-source>
<rows>
    <row>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
    </row>
</rows>
                </xml-source>
                <note>
                    <p>
                        Base64-encoded binary documents are widely used in OPS, in
                        particular in the following cases:
                    </p>
                    <ul>
                        <li>
                            <p>
                                <a href="processors-generators-request">Request
                                generator</a>: as the result of certain types of HTML form
                                submissions (typically file uploads) or request body submission,
                                Base64-encoded representation of the uploaded files may be stored
                                into the request document.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="reference-xforms-ng#upload">XForms upload</a>: as the result
                                of a file upload, a Base64-encoded representation of the uploaded
                                file may be stored into the XForms instance.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="processors-generators-url">URL generator</a>:
                                can read binary documents and produce Base64-encoded output
                                according to the standard <a
                                href="reference-formats#binary-documents">binary document
                                format</a>.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="processors-serializers-http">HTTP
                                serializer</a>: can convert Base64-encoded input according to the
                                <a href="reference-formats#binary-documents">binary document
                                format</a> into a binary stream.
                            </p>
                        </li>
                        <li>
                            <p>
                                SQL processor: as described in this document, it is able to read
                                and write Base64-encoded binaries.
                            </p>
                        </li>
                    </ul>
                </note>
                <warning>
                    <p>
                        Writing to BLOB columns is currently only supported with the following
                        application server / database combinations:
                    </p>
                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>
                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from BLOB columns on the other hand is supported with all JDBC
                        drivers that support the BLOB API.
                    </p>
                </warning>
            </section>
            <section>
                <title>sql:value-of and sql:copy-of</title>
                <p>
                    The <code>sql:value-of</code> and <code>sql:copy-of</code> elements have the
                    same semantics as their XSLT 1.0 couterparts. They work against the SQL
                    processor's input XML document.
                </p>
                <p>
                    Those elements support functions in the
                    <code>http://orbeon.org/oxf/xml/sql</code> namespace. The only function
                    supported for the moment is <code>sql:row-position()</code>, which returns, in a
                    <code>sql:row-iterator</code>, the index of the current row in the result set,
                    starting with row number <code>1</code>. For example:
                </p>
                <xml-source>
                    <sql:result-set xmlns:sql="http://orbeon.org/oxf/xml/sql">
                        <sql:row-iterator>
                            <employee>
                                <position><sql:value-of select="sql:row-position()"/></position>
                                <first-name><sql:get-column-value type="xs:string" column="first_name"/></first-name>
                                <last-name><sql:get-column-value type="xs:string" column="last_name"/></last-name>
                            </employee>
                        </sql:row-iterator>
                    </sql:result-set>
                </xml-source>
                <p>
                    This generates the following results:
                </p>
                <xml-source>
                    <employee>
                        <position>1</position>
                        <first-name>John</first-name>
                        <last-name>Doe</last-name>
                    </employee>
                    <employee>
                        <position>2</position>
                        <first-name>Billy</first-name>
                        <last-name>Smith</last-name>
                    </employee>
                </xml-source>
            </section>
            <section>
                <title>Multiple Updates</title>
                <p>
                    The <code>sql:update</code> element supports an optional
                    <code>select</code> attribute. It is evaluated as an XPath
                    expression against the input XML document. The expression must
                    return a node-set (which may be empty). The update statement is
                    executed once for every node returned. <code>select</code>
                    attributes on nested <code>sql:param</code> elements are
                    evaluated using the selected node as current node. With the
                    following input XML document:
                </p>
                <xml-source>
<employees>
    <employee>
        <first-name>John</first-name>
        <last-name>Doe</last-name>
    </employee>
    <employee>
        <first-name>Billy</first-name>
        <last-name>Smith</last-name>
    </employee>
</employees>
                </xml-source>
                <p>The following update inserts two rows in the database:</p>
                <xml-source>
<sql:update select="/employees/employee" xmlns:sql="http://orbeon.org/oxf/xml/sql">
insert into employee (first_name, last_name)
       values (<sql:param type="xs:string" select="first-name"/>,
               <sql:param type="xs:string" select="last-name"/>)
</sql:update>
                </xml-source>
            </section>
            <section>
                <title>Nested queries</title>
                <p>
                    Consider the following three SQL tables organized in a tree.
                    The level2 table references the level1 table, and the level3
                    table references the level2 table.
                </p>
                <p>level1</p>
                <table>
                    <tr><th>level1_id</th><th>value</th></tr>
                    <tr><td>1</td><td>a</td></tr>
                    <tr><td>2</td><td>b</td></tr>
                </table>
                <p>level2</p>
                <table>
                    <tr><th>level2_id</th><th>level1_id</th><th>value</th></tr>
                    <tr><td>1</td><td>1</td><td>a</td></tr>
                    <tr><td>2</td><td>1</td><td>b</td></tr>
                    <tr><td>3</td><td>2</td><td>c</td></tr>
                    <tr><td>4</td><td>2</td><td>d</td></tr>
                </table>
                <p>level3</p>
                <table>
                    <tr><th>level2_id</th><th>value</th></tr>
                    <tr><td>1</td><td>a</td></tr>
                    <tr><td>1</td><td>b</td></tr>
                    <tr><td>2</td><td>c</td></tr>
                    <tr><td>2</td><td>d</td></tr>
                    <tr><td>3</td><td>e</td></tr>
                    <tr><td>3</td><td>f</td></tr>
                    <tr><td>4</td><td>g</td></tr>
                    <tr><td>4</td><td>h</td></tr>
                </table>
                <p>A flat representation of the three tables joined on their
                respective foreign keys yields the following rows:</p>
                <table>
                    <tr><th>level1.value</th><th>level2.value</th><th>level3.value</th></tr>
                    <tr><td>a</td><td>a</td><td>a</td></tr>
                    <tr><td>a</td><td>a</td><td>b</td></tr>
                    <tr><td>a</td><td>b</td><td>c</td></tr>
                    <tr><td>a</td><td>b</td><td>d</td></tr>
                    <tr><td>b</td><td>c</td><td>e</td></tr>
                    <tr><td>b</td><td>c</td><td>f</td></tr>
                    <tr><td>b</td><td>d</td><td>g</td></tr>
                    <tr><td>b</td><td>d</td><td>h</td></tr>
                </table>
                <p>Often it is useful to group results in order to output certain
                values only once. In a table, this can look like the following:</p>
                <table>
                    <tr><th>level1.value</th><th>level2.value</th><th>level3.value</th></tr>
                    <tr><td rowspan="4">a</td>  <td rowspan="2">a</td>  <td>a</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>b</td></tr>
                    <tr><pdf-td/>               <td rowspan="2">b</td>  <td>c</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>d</td></tr>
                    <tr><td rowspan="4">b</td>  <td rowspan="2">c</td>  <td>e</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>f</td></tr>
                    <tr><pdf-td/>               <td rowspan="2">d</td>  <td>g</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>h</td></tr>
                </table>
                <p>A generalization of this consists in generating output of the form:</p>
                <xml-source>
<result>
    <group1>
        <group1-header><level1-value>a</level1-value></group1-header>
        <group1-members>
            <group2>
                <group2-header><level2-value>a</level2-value></group2-header>
                    <group2-members>
                        <level3-value>a</level3-value>
                        <level3-value>b</level3-value>
                    </group2-members>
                <group2-footer><level2-value>a</level2-value></group2-footer>
            </group2>
            <group2>
                <group2-header><level2-value>b</level2-value></group2-header>
                    <group2-members>
                        <level3-value>c</level3-value>
                        <level3-value>d</level3-value>
                    </group2-members>
                <group2-footer><level2-value>b</level2-value></group2-footer>
            </group2>
        </group1-members>
        <group1-footer><level1-value>a</level1-value></group1-footer>
    </group1>
    <group1>
        <group1-header><level1-value>b</level1-value></group1-header>
        <group1-members>
            <group2>
                <group2-header><level2-value>c</level2-value></group2-header>
                    <group2-members>
                        <level3-value>e</level3-value>
                        <level3-value>f</level3-value>
                    </group2-members>
                <group2-footer><level2-value>c</level2-value></group2-footer>
            </group2>
            <group2>
                <group2-header><level2-value>d</level2-value></group2-header>
                    <group2-members>
                        <level3-value>g</level3-value>
                        <level3-value>h</level3-value>
                    </group2-members>
                <group2-footer><level2-value>d</level2-value></group2-footer>
            </group2>
        </group1-members>
        <group1-footer><level1-value>b</level1-value></group1-footer>
    </group1>
</result>
                </xml-source>
                <p>
                    There are two ways of generating such results. The first way is to use nested
                    queries. A first query returns all the rows in the level1 table. Then, for each row
                    returned, a second query returns all rows in the level2 table referencing the
                    current row's level1_id. Similarly, for each row returned by that second query, a
                    new query is done to get the relevant level3 rows. The code would look as
                    follows:
                </p>
                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <results>
        <sql:connection>
            <sql:datasource>my-datasource</sql:datasource>
            <sql:execute>
                <sql:query>
select level1.value value, level1.level1_id id
  from level1
 order by level1.value
                </sql:query>
                <sql:result-set>
                    <sql:row-iterator>
                        <group1>
                            <group1-header>
                                <level1-value><sql:get-column-value type="xs:string" column="value"/></level1-value>
                            </group1-header>
                            <group1-members>
                                <sql:execute>
                                    <sql:query>
select level2.value value, level2.level2_id id
  from level2
 where level2.level1_id = <sql:param type="xs:int"><sql:get-column-value type="xs:int" column="id"/></sql:param>
 order by level2.value
                                    </sql:query>
                                    <sql:result-set>
                                        <sql:row-iterator>
                                            <group2>
                                                <group2-header>
                                                    <level2-value><sql:get-column-value type="xs:string" column="value"/></level2-value>
                                                </group2-header>
                                                <group2-members>
                                                    <sql:execute>
                                                        <sql:query>
select level3.value value
  from level3
 where level3.level2_id = <sql:param type="xs:int"><sql:get-column-value type="xs:int" column="id"/></sql:param>
 order by level3.value
                                                        </sql:query>
                                                        <sql:result-set>
                                                            <sql:row-iterator>
                                                                <level3-value><sql:get-column-value type="xs:string" column="value"/></level3-value>
                                                            </sql:row-iterator>
                                                        </sql:result-set>
                                                    </sql:execute>
                                                </group2-members>
                                                <group2-footer>
                                                    <level2-value><sql:get-column-value type="xs:string" column="value"/></level2-value>
                                                </group2-footer>
                                            </group2>
                                        </sql:row-iterator>
                                    </sql:result-set>
                                </sql:execute>
                            </group1-members>
                            <group1-footer>
                                <level1-value><sql:get-column-value type="xs:string" column="value"/></level1-value>
                            </group1-footer>
                        </group1>
                    </sql:row-iterator>
                </sql:result-set>
            </sql:execute>
        </sql:connection>
    </results>
</sql:config>
                </xml-source>

                <p>
                    A nested query can access parameters from the input XML document like any
                    regular query. It can also access results from outer queries by nesting a getter
                    in a <code>sql:param</code> element. In that case, getters can take an optional
                    <code>ancestor</code> attribute that specifies which level of outer query to
                    access. If omitted, the <code>ancestor</code> attribute takes the value 1 when
                    used in a <code>sql:query</code> or <code>sql:update</code>, which means the
                    first outer query; it defaults to the value 0 when used in a
                    <code>sql:row-iterator</code>, which means the query at the current level.
                </p>
            </section>
            <section>
                <title>Grouping With sql:group and sql:member</title>
                <p>
                    While nested queries have their uses, in the example above 3 queries have to be
                    written and no less than 7 queries are executed to produce the final result. It
                    can be elegantly rewritten using the <code>sql:group</code> and
                    <code>sql:member</code> elements. <code>sql:group</code> has to be the first
                    element under a <code>sql:row-iterator</code> or <code>sql:member</code>
                    element. It takes a mandatory <code>column-name</code> attribute that specifies
                    the name of the column on which grouping is done.
                </p>
                <p>
                    For every group, a header is output only once. Then, the content under the
                    <code>sql:member</code> element is output for each row. Finally, the footer is
                    output. The header and the footer can access columns There is no limit in as to
                    how deep grouping can be done.
                </p>
                <p>
                    The code below generates with a single SQL query the same results as the
                    example above:
                </p>
                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <results>
        <sql:connection>
            <sql:datasource>my-datasource</sql:datasource>
            <sql:execute>
                <sql:query>
select level1.value v1, level2.value v2, level3.value v3
  from level1, level2, level3
 where level1.level1_id = level2.level1_id
   and level2.level2_id = level3.level2_id
 order by level1.value, level2.value, level3.value
                </sql:query>
                <sql:result-set>
                    <sql:row-iterator>
                        <sql:group column="v1">
                            <group1>
                                <group1-header>
                                    <level1-value><sql:get-column-value type="xs:string" column="v1"/></level1-value>
                                </group1-header>
                                <group1-members>
                                    <sql:member>
                                        <sql:group column="v2">
                                            <group2>
                                                <group2-header>
                                                    <level2-value><sql:get-column-value type="xs:string" column="v2"/></level2-value>
                                                </group2-header>
                                                <group2-members>
                                                    <sql:member>
                                                        <level3-value><sql:get-column-value type="xs:string" column="v3"/></level3-value>
                                                    </sql:member>
                                                </group2-members>
                                                <group2-footer>
                                                    <level2-value><sql:get-column-value type="xs:string" column="v2"/></level2-value>
                                                </group2-footer>
                                            </group2>
                                        </sql:group>
                                    </sql:member>
                                </group1-members>
                                <group1-footer>
                                    <level1-value><sql:get-column-value type="xs:string" column="v1"/></level1-value>
                                </group1-footer>
                            </group1>
                        </sql:group>
                    </sql:row-iterator>
                </sql:result-set>
            </sql:execute>
        </sql:connection>
    </results>
</sql:config>
                </xml-source>
                <p>
                    Note that correct ordering of the rows in the SQL query is
                    important because headers and footers are output when the
                    columns on which grouping is done change, in the order
                    returned by the result set.
                </p>
            </section>
            <section>
                <title>Text and Whitespace Handling</title>
                <p>
                    Like in XSLT 1.0, text nodes in the configuration containing only whitespace
                    characters are stripped. Text nodes that contain at least one non-whitespace
                    character are not stripped and copied to the output.
                </p>
                <p>
                    To better control the output of text, the <code>sql:text</code> element is
                    provided. It is similar to the <code>xsl:text</code> element.
                    <code>xsl:text</code> encapsulate text that is output as is. In particular, it
                    can encapsulate all whitespace characters.
                </p>
            </section>
        </section>
        <section>
            <title>Transactions Management</title>
            <p>
                OPS executes each HTTP request in its own transaction. If a request fails for any
                reason, the SQL Processor rolls back the transaction. The transaction is committed
                only when the pipeline execution in complete.
            </p>
        </section>
    </body>
</document>
