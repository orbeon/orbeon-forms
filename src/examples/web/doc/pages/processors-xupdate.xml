<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
    Copyright (C) 2004 Orbeon, Inc.

    The Orbeon documentation is not distributed under the LGPL license. Use of the documentation is
    subject to the following terms:

    * Conversion to other formats is allowed, but the actual content may not be altered or edited
      in any way.

    * You may create printed copies for your own personal use.

    * For all other uses, such as selling printed copies or using (parts of) the manual in another
      publication, prior written agreement from Orbeon, Inc. is required.

    Please contact Orbeon at info@orbeon.com for more information.
-->
<document xmlns:p="http://www.orbeon.com/oxf/pipeline" xmlns:xforms="http://www.w3.org/2002/xforms">
    <header>
        <title>XUpdate Processor</title>
    </header>
    <body>
        <section>
            <title>Scope</title>
            <p>
                This section provides an overview of the XUpdate language, the
                OPS XUpdate engine, and the extensions to the XUpdate language
                supported by the OPS XUpdate engine. It also features examples
                programs written in XUpdate.
            </p>
            <p>
                For more information on how to use the OPS XUpdate engine
                directly from Java programs, see the <link
                href="integration-xupdate">XUpdate section</link> in
                <i>Integration</i>.
            </p>
        </section>
        <section>
            <title>About XUpdate</title>
            <section>
                <title>Origin</title>
                <p>
                    The <link href="http://xmldb-org.sourceforge.net/">XML:DB group</link> has been
                    working on a specification for a language to describes how to update an XML
                    document. The latest version of the <link
                    href="http://xmldb-org.sourceforge.net/xupdate/xupdate-wd.html">XUpdate
                    specification</link> was released in 2000 as a working draft. Since then,
                    XUpdate has been used in a number of situations to update XML documents, in
                    particular in XML databases like <link
                    href="http://exist.sourceforge.net/">eXist</link>, <link
                    href="http://xml.apache.org/xindice/">Xindice</link> and <link
                    href="http://www.x-hive.com/">X-Hive/DB</link>.
                </p>
            </section>
            <section>
                <title>The OPS XUpdate Engine</title>
                <p>
                    XUpdate does not provide means to declare variables, iterate
                    over a node set, or declare functions. In addition to the
                    XUpdate specification, the OPS XUpdate engine implements a
                    set of extensions to allow all of the above.
                </p><p>
                    The XUpdate language was designed to be consistent with
                    XSLT, so it would be natural for developers who are familiar
                    with XSLT to use XUpdate. The extensions to the XUpdate
                    specification implemented in the OPS XUpdate engine follow
                    the same design principle as they closely mimic their XSLT
                    counterpart.
                </p>
            </section>
            <section>
                <title>Best Practices</title>
                <p>
                    An XUpdate transformation is similar to an XSLT
                    transformation:
                </p>
                <ul>
                    <li>
                        As shown in the illustration below, just like XSLT,
                        XUpdate transforms an XML input document into an XML
                        output document based on a "configuration". With XSLT,
                        the configuration is an XSLT stylesheet. With XUpdate,
                        the configuration is a program written in the XUpdate
                        language.
                    </li>
                    <img print-format="pdf" src="pages/processors-xupdate-processor.png"/>
                    <li>
                        The XSLT and XUpdate languages have similar expressive
                        power, they both use XPath as the expression language
                        and share elements names in a consistent way.
                    </li>
                </ul>

                <p>
                    Every program written in XSLT could also be written in
                    XUpdate and vice versa. A natural question would be: when is
                    it more appropriate to use XUpdate and when is it more
                    appropriate to use XSLT? XSLT and XUpdate are set apart by
                    their distinctive processing model: in XSLT nodes from the
                    input document trigger the execution of templates that
                    define the output document, while an XUpdate provides the
                    sequence of operations to be performed on the input document
                    to create the output document.
                </p>
                <p>
                    As a rule of thumb, XUpdate is more appropriate when the
                    output document is similar to the input document, while XSLT
                    is more appropriate when the output document is a new
                    document in which values from the input document are
                    inserted. This can be summarized in the table below:
                </p>

                <table>
                    <tr>
                        <th/>
                        <th>XSLT</th>
                        <th>XUpdate</th>
                    </tr>
                    <tr>
                        <th>Execution model</th>
                        <td>
                            Nodes from the input document trigger the execution
                            of templates that define the output document
                        </td>
                        <td>
                            XUpdate provides a sequence of operations to be
                            performed on the input document to create the
                            output document
                        </td>
                    </tr>
                    <tr>
                        <th>Most appropriate when</th>
                        <td>
                            When the output document is a new document in which
                            values from the input document are inserted
                        </td>

                        <td>
                            When the output document is similar to the input
                            document
                        </td>
                    </tr>
                    <tr>
                        <th>Typical applications</th>
                        <td>
                            XSLT can be used as a template language, for
                            instance to create an HTML page with both dynamic
                            and static data. The input document contains the
                            dynamic data. The stylesheets contains the static
                            data and describes how the dynamic data is inserted
                            in the document. Doing the same thing in XUpdate
                            would be unnecessarily complicated.
                        </td>
                        <td>
                            <p>
                                XUpdate can be used as an annotation language,
                                for instance to validate elements of an input
                                document and to add an attribute on those
                                elements stating if they are valid or not.
                                Another usage is when annotating an XML document
                                to add calculated values based on existing
                                values. Some of the examples below do exactly
                                that.
                            </p>
                            <p>
                                Some cases, for instance when a parent elements
                                has to be updated based on updates previously
                                done to child elements, cannot be handled with
                                XSLT 1.0 without using XSLT extensions or
                                pipelining multiple stylesheets.
                            </p>
                        </td>
                    </tr>
                </table>
            </section>
        </section>
        <section>
            <title>Language Reference</title>
            <p>
                All the XUpdate elements mentioned here must be in the
                <code>http://www.xmldb.org/xupdate</code> namespace and for
                brevity we use the <code>xu</code> prefix.
            </p>
            <section>
                <title>Standard elements</title>
                <p>
                    The elements below are defined in the <link
                    href="http://xmldb-org.sourceforge.net/xupdate/xupdate-wd.html">XUpdate
                    specification</link>.
                </p>
                <ul>
                    <li><code>&lt;xu:modifications version="1.0"&gt;</code></li>
                    <li><code>&lt;xu:value-of select="expression"&gt;</code></li>
                    <li><code>&lt;xu:if test="expression"&gt;</code></li>
                    <li><code>&lt;xu:insert-before select="expression"&gt;</code></li>
                    <li><code>&lt;xu:insert-after select="expression"&gt;</code></li>
                    <li><code>&lt;xu:append select="expression" child="expression"&gt;</code></li>
                    <li><code>&lt;xu:remove select="expression"&gt;</code></li>
                    <li><code>&lt;xu:update select="expression"&gt;</code></li>
                    <li> <code>&lt;xu:variable name="qname" select="expression"&gt;</code></li>
                    <li><code>&lt;xu:element name="qname"&gt;</code></li>
                    <li><code>&lt;xu:attribute name="qname"&gt;</code></li>
                </ul>
            </section>
            <section>
                <title>Extensions</title>
                <ul>
                    <li>
                        <p>
                            <code>&lt;xu:function name="<i>qname</i>"&gt;</code>
                            — Defines a function with the given name. The
                            element can contain <code>&lt;xu:param
                            name="<i>qname</i>"
                            select="<i>expression</i>"&gt;</code> elements that
                            define the parameters of the function. Functions
                            defined with <code>&lt;xu:function&gt;</code> are
                            called from XPath expressions, just like regular
                            XPath functions.
                        </p>
                        <p>
                            Functions in XUpdate, just like variables, can be
                            declared anywhere, not only at the top level. In
                            particular, they can also be declared inside other
                            functions. The visibility rules for functions are
                            the same as those for variables: a function has a
                            visibility on the context where it is declared and
                            is visible only inside the block where it is
                            declared.
                        </p>
                        <p>
                            Functions in XUpdate are first-class citizen: just
                            like variables they can be passed as arguments and
                            returned by other functions. <link
                            href="#functions-first-class">An example</link>
                            later in this section illustrates how this works.
                        </p>
                    </li>

                    <li>
                        <p>
                            <code>&lt;xu:choose&gt;</code> — Contains one or
                            more <code>&lt;xu:when
                            test="<i>expression</i>"&gt;</code> elements and an
                            optional <code>&lt;xu:otherwise&gt;</code>. The
                            content of the first <code>&lt;xu:when&gt;</code>
                            where the test condition is true is executed. If
                            none is true, the content of
                            <code>&lt;xu:otherwise&gt;</code> is executed if
                            present.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:copy-of
                            select="<i>expression</i>"&gt;</code> — Performs a
                            copy of what is returned by the select expression.
                            Unlike <code>&lt;xu:value-of&gt;</code>, the result
                            of the expression is not converted to a string
                            before it is returned.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:for-each
                            select="<i>expression</i>"&gt;</code> — Iterates
                            over the node set returned by the <code>select</code> expression
                            and executes the content of the
                            <code>&lt;xu:for-each&gt;</code> for every node in
                            the node set with that node as the current context.
                        </p>
                        <p>
                            Note that in the case below, the content of the <code>data</code> variable
                            is updated, not the input document (so in this case, the input
                            document will be left unchanged):

                            <xml-source>
                                <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                                    <xu:variable name="company" select="document('oxf:/xupdate/input.xml')"/>
                                    <xu:for-each select="$company/company/year">
                                        <xu:variable name="position" select="position()"/>
                                        <xu:update select="/company/year[$position]"><xu:value-of select="@id"/></xu:update>
                                    </xu:for-each>
                                    <comment>Statements using $company</comment>
                                </xu:modifications>
                            </xml-source>
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:while
                            select="<i>expression</i>"&gt;</code> — Executes
                            the content of the <code>&lt;xu:while&gt;</code>
                            while the condition in the <code>select</code>
                            expression is true.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:assign
                            select="<i>expression</i>"&gt;</code> — Replaces
                            the content of a variable. Once the value of a
                            variable is set, it is possible to update parts of
                            its contents with statements like
                            <code>&lt;xu:update></code>. However no other
                            statements we'll let you replace the root element of
                            the variable, or the value of the variable if it is
                            a simple type. To do so you need to use
                            <code>&lt;xu:assign></code>. The new value can be a
                            either specified as an XPath expression with the
                            <code>select</code> attribute, or in the contents of
                            the <code>&lt;xu:update></code> element.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:message&gt;</code> — Just like 
                            <code>&lt;xsl:message></code>, logs the content of the element.
                            For instance, to log the document being currently updated, use
                            <code>&lt;xu:message>&lt;xu:copy-of select="/*"/>&lt;/xu:message></code>.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:error></code> – The XUpdate program is interrupted as an
                            exception is thrown with the result of the evaluation of the element
                            content.
                        </p>
                    </li>
                    <li>
                        <p>
                            <code>&lt;xu:namespace></code> – Adds a namespace declaration on the
                            current element, just like the XSLT <code>&lt;xsl:namespace></code>.
                        </p>
                    </li>
                </ul>
            </section>
            <section>
                <title>Incompatibilities</title>
                <ul>
                    <li>
                        <p>
                            The <code>&lt;xu:value-of&gt;</code> as described in
                            the XUpdate specification works like the XSLT
                            <code>&lt;xsl:copy-of&gt;</code> but the XUpdate
                            specification provides no equivalent to the XSLT
                            <code>&lt;xsl:value-of&gt;</code>.
                        </p>

                        <p>
                            We find this situation both confusing and
                            restrictive. It is confusing because more people
                            know about XSLT than XUpdate and they will be
                            surprised if <code>&lt;xu:value-of&gt;</code> has a
                            different behavior than the one they expected. It is
                            restrictive because the XUpdate specification
                            provides no equivalent to the XSLT
                            <code>&lt;xsl:value-of&gt;</code> functionality.
                        </p>

                        <p>
                            For these reasons the OPS XUpdate engine implements
                            both <code>&lt;xu:value-of&gt;</code> and
                            <code>&lt;xu:copy-of&gt;</code> as in XSLT.
                        </p>
                    </li>
                </ul>
            </section>
            <a name="xpath"/>
            <section>
                <title>XPath</title>
                <p>
                    In a number of places you can use XPath expressions. In addition to standard
                    XPath 1.0, you can use the following list of extension functions:
                </p>
                <ul>
                    <li>
                        The XPath 2.0 function <code>get-namespace-uri-for-prefix()</code>
                        is supported (the XPath engine is still 1.0 compliant, not
                        2.0).
                    </li>
                    <li>
                        <code>evaluate(xpath, namespaces, nodeset)</code> – Evaluates the
                        first string argument as an XPath expression in the context of the
                        third nodeset argument. Any prefix used in the XPath expression must
                        be defined in the second argument, which is a nodeset of namespace
                        nodes.
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <title>Using the XUpdate Processor</title>
            <section>
                <title>Interface</title>
                <p>
                    The XUpdate processor has the same interface as the XSLT
                    processor. It takes two inputs: <code>config</code>, the
                    XUpdate program, and <code>data</code>, the document to
                    update. In XPL, the XUpdate processor can be invoked with:
                </p>

                <xml-source>
                    <p:processor name="oxf:xupdate">
                        <p:input name="config" href="xupdate.xml"/>
                        <p:input name="data" href="#data"/>
                        <p:output name="data" id="output"/>
                    </p:processor>
                </xml-source>
            </section>
            <section>
                <title>Using Multiple Documents</title>

                <p>
                    It is not uncommon that a given document needs to be
                    updated based on information stored in other documents. For
                    example, in the situation illustrated below the document on
                    the left is modified based on three other documents
                    <i>a</i>, <i>b</i> and <i>c</i>.
                </p>

                <img print-format="pdf" src="pages/processors-xupdate-doc.png"/>

                <p>
                    When calling the XUpdate processor from XPL, this is done
                    by connecting the three documents to the inputs of the
                    XUpdate processor named <i>a</i>, <i>b</i> and <i>c</i>.
                    Then the XUpdate program has access to those documents
                    through XPath expressions with the <code>document()</code>
                    or <code>doc()</code> functions using the URI
                    <code>#a</code>, <code>#b</code> and <code>#c</code>. Note
                    that any name can be chosen except <code>data</code> and
                    <code>config</code> since those are reserved for the
                    document to update and the XUpdate program. Invoking the
                    XUpdate processor in this scenario could be done as follows:
                </p>

                <xml-source>
                    <p:processor name="oxf:xupdate">
                        <p:input name="config" href="xupdate.xml"/>
                        <p:input name="data" href="#data"/>
                        <p:input name="a" href="x.xml"/>
                        <p:input name="b" href="y.xml"/>
                        <p:input name="c" href="z.xml"/>
                        <p:output name="data" id="output"/>
                    </p:processor>
                </xml-source>
            </section>
        </section>
        <section>
            <title>Examples</title>
            <section>
                <title>Input Document</title>
                <p>
                    All the examples have been designed to the work on the
                    sample document given below. This document provides numbers
                    reflecting the sales of a company divided by quarter and by
                    year.
                </p>
                <xml-source>
                    <company>
                        <year id="2000">
                            <quarter id="1" sales="80"/>
                            <quarter id="2" sales="56"/>
                            <quarter id="3" sales="97"/>
                            <quarter id="4" sales="150"/>
                        </year>
                        <year id="2001">
                            <quarter id="1" sales="20"/>
                            <quarter id="2" sales="54"/>
                            <quarter id="3" sales="80"/>
                            <quarter id="4" sales="90"/>
                        </year>
                        <year id="2002">
                            <quarter id="1" sales="54"/>
                            <quarter id="2" sales="65"/>
                            <quarter id="3" sales="96"/>
                            <quarter id="4" sales="164"/>
                        </year>
                    </company>
                </xml-source>
            </section>
            <section>
                <title>Leaf to Root Document Annotation</title>

                <p>
                    The goal is to add a <code>change</code> attribute to the
                    <code>quarter</code> element with the difference between the
                    numbers for that quarter and the same quarter one year
                    before. We also want to add a <code>change</code> attribute
                    to the <code>year</code> element computed as the sum of the
                    <code>change</code> attributes on its children elements.
                    Obviously no <code>change</code> attribute can be added to
                    the <code>year</code> and <code>quarter</code> elements of
                    the first year. The output document looks like:
                </p>
                <xml-source>
                    <company>
                        <year id="2000">
                            <quarter id="1" sales="80"/>
                            <quarter id="2" sales="56"/>
                            <quarter id="3" sales="97"/>
                            <quarter id="4" sales="150"/>
                        </year>
                        <year id="2001" change="-139">
                            <quarter id="1" sales="20" change="-60"></quarter>
                            <quarter id="2" sales="54" change="-2"></quarter>
                            <quarter id="3" sales="80" change="-17"></quarter>
                            <quarter id="4" sales="90" change="-60"></quarter>
                        </year>
                        <year id="2002" change="135">
                            <quarter id="1" sales="54" change="34"></quarter>
                            <quarter id="2" sales="65" change="11"></quarter>
                            <quarter id="3" sales="96" change="16"></quarter>
                            <quarter id="4" sales="164" change="74"></quarter>
                        </year>
                    </company>
                </xml-source>
                <p>
                    What is particular in this example is that the most
                    convenient way to implement the requirement is to first add
                    an attribute to a set of elements (quarters) and then to
                    update the parent elements (years) based on the values
                    previously computed. This is typically hard to do in XSLT,
                    but is quite natural in XUpdate:
                </p>
                <xml-source>
                    <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                        <comment>Add the change attribute to the quarter elements</comment>
                        <xu:for-each select="/company/year[position() > 1]">
                            <xu:variable name="last-year" select="preceding::year"/>
                            <xu:for-each select="quarter">
                                <xu:variable name="quarter" select="@id"/>
                                <xu:append select=".">
                                    <xu:attribute name="change">
                                        <xu:value-of select="@sales - $last-year/quarter[@id = $quarter]/@sales"/>
                                    </xu:attribute>
                                </xu:append>
                            </xu:for-each>
                        </xu:for-each>
                        <comment>Add the change attribute at the year level by computing</comment>
                        <comment>the sum of the changes at the quarter level</comment>
                        <xu:for-each select="/company/year[position() > 1]">
                            <xu:append select=".">
                                <xu:attribute name="change">
                                    <xu:value-of select="sum(quarter/@change)"/>
                                </xu:attribute>
                            </xu:append>
                        </xu:for-each>
                    </xu:modifications>
                </xml-source>
            </section>
            <section>
                <title>Iterative Document Annotation</title>

                <p>
                    The idea is to add a <code>change</code> attribute to the
                    <code>quarter</code> elements, like in the previous example.
                    In addition, a <code>variation</code> attribute must be
                    added to the <code>quarter</code> elements with the
                    difference between the <code>change</code> value of the
                    current quarter and the <code>change</code> value of the
                    previous quarter. Obviously, the <code>variation</code>
                    attribute cannot be added to the first quarter of the second
                    year. The output document looks like:
                </p>
                <xml-source>
                    <company>
                        <year id="2000">
                            <quarter id="1" sales="80"/>
                            <quarter id="2" sales="56"/>
                            <quarter id="3" sales="97"/>
                            <quarter id="4" sales="150"/>
                        </year>
                        <year id="2001">
                            <quarter id="1" sales="20" change="-60"/>
                            <quarter id="2" sales="54" change="-2" variation="58"></quarter>
                            <quarter id="3" sales="80" change="-17" variation="-15"></quarter>
                            <quarter id="4" sales="90" change="-60" variation="-43"></quarter>
                        </year>
                        <year id="2002">
                            <quarter id="1" sales="54" change="34" variation="94"></quarter>
                            <quarter id="2" sales="65" change="11" variation="-23"></quarter>
                            <quarter id="3" sales="96" change="16" variation="5"></quarter>
                            <quarter id="4" sales="164" change="74" variation="58"></quarter>
                        </year>
                    </company>
                </xml-source>
                <p>
                    What is special in this example, is that the most natural
                    way to implement the requirement is in a two-pass algorithm:
                    first add the <code>change</code> attribute, then the
                    <code>variation</code> attribute based on the value
                    previously computed. Iterative algorithms can be implemented
                    in XSLT but the exercise adds unnecessary complexity and
                    often requires the use of XSLT extensions or multiple
                    pipelined XSLT stylesheets. Instead, iterative algorithms
                    can be expressed very naturally with XUpdate:
                </p>
                <xml-source>
                    <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                        <xu:for-each select="/company/year[position() > 1]">
                            <xu:variable name="last-year" select="preceding::year"/>
                            <xu:for-each select="quarter">
                                <xu:variable name="quarter" select="@id"/>
                                <xu:append select=".">
                                    <xu:attribute name="change">
                                        <xu:value-of select="@sales - $last-year/quarter[@id = $quarter]/@sales"/>
                                    </xu:attribute>
                                </xu:append>
                            </xu:for-each>
                        </xu:for-each>
                        <xu:for-each select="/company/year/quarter">
                            <xu:if test="preceding::quarter/@change">
                                <xu:append select=".">
                                    <xu:attribute name="variation">
                                        <xu:value-of select="@change - preceding::quarter/@change"/>
                                    </xu:attribute>
                                </xu:append>
                            </xu:if>
                        </xu:for-each>
                    </xu:modifications>
                </xml-source>
            </section>
            <section>
                <title>Simple Functions</title>
                <p>
                    The XUpdate program below adds a <code>change</code>
                    attribute on the <code>quarter</code> elements just like the
                    previous two examples. But, in this case, the logic to add
                    the <code>change</code> attribute to a given element is in a
                    function and that function is called from some code that
                    iterates over the quarters. Here, functions are used in
                    XUpdate just like they would be used in XSLT 2.0.
                </p>
                <xml-source>
                    <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                        <xu:function name="add-change">
                            <xu:param name="last-quarter"/>
                            <xu:param name="this-quarter"/>
                            <xu:append select="$this-quarter">
                                <xu:attribute name="change">
                                    <xu:value-of select="$this-quarter/@sales - $last-quarter/@sales"/>
                                </xu:attribute>
                            </xu:append>
                        </xu:function>
                        <xu:for-each select="/company/year[position() > 1]/quarter">
                            <xu:variable name="id" select="@id"/>
                            <xu:value-of select="add-change(preceding::year/quarter[@id = $id], .)"/>
                        </xu:for-each>
                    </xu:modifications>
                </xml-source>
            </section>
            <a name="functions-first-class"/>
            <section>
                <title>Functions as First-Class Citizens</title>
                <p>
                    The OPS XUpdate engine allows for top-level functions called
                    from XPath expressions, like XSLT 2. Additionally:
                </p>
                <ul>
                    <li>
                        Functions can be declared anywhere in the program,
                        including inside other functions. The visibility rules
                        for functions are the same as those for variables.
                    </li>
                    <li>
                        Functions can be assigned to variables, passed as
                        arguments to other functions and returned by functions.
                        Languages providing this capability are said to treat
                        functions as first-class citizen.
                    </li>
                </ul>
                <p>
                    The XUpdate program below adds a <code>change</code>
                    attribute to the <code>quarter</code> elements just like the
                    previous examples. The <code>add-change</code> function is
                    taken from the previous example. In addition, the logic to
                    iterate over the quarters has been coded in a function
                    <code>apply-on-quarter</code> that takes one argument: the
                    function to apply to each quarter.
                </p>
                <xml-source>
                    <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                        <xu:function name="add-change">
                            <xu:param name="last-quarter"/>
                            <xu:param name="this-quarter"/>
                            <xu:append select="$this-quarter">
                                <xu:attribute name="change">
                                    <xu:value-of select="$this-quarter/@sales - $last-quarter/@sales"/>
                                </xu:attribute>
                            </xu:append>
                        </xu:function>
                        <xu:function name="apply-on-quarter">
                            <xu:param name="f"/>
                            <xu:for-each select="/company/year[position() > 1]/quarter">
                                <xu:variable name="id" select="@id"/>
                                <xu:value-of select="f(preceding::year/quarter[@id = $id], .)"/>
                            </xu:for-each>
                        </xu:function>
                        <xu:value-of select="apply-on-quarter($add-change)"/>
                    </xu:modifications>
                </xml-source>
                <p>
                    The example below uses the full power of the OPS XUpdate
                    engine first-class citizen functions:
                </p>
                <xml-source>
                    <xu:modifications xmlns:xu="http://www.xmldb.org/xupdate">
                        <xu:function name="double">
                            <xu:param name="f"/>
                            <xu:function name="result">
                                <xu:param name="x"/>
                                <xu:value-of select="f($x) * 2"/>
                            </xu:function>
                            <xu:copy-of select="$result"/>
                        </xu:function>

                        <xu:function name="increment">
                            <xu:param name="x"/>
                            <xu:value-of select="$x + 1"/>
                        </xu:function>

                        <xu:variable name="incrementAndDouble" select="double($increment)"/>
                        <xu:update select="/">
                            <result>
                                <xu:value-of select="incrementAndDouble(2)"/>
                            </result>
                        </xu:update>
                    </xu:modifications>
                </xml-source>
                <p>
                    At the top level, the above XUpdate program defines two
                    functions:
                </p>
                <ul>
                    <li>
                        <code>increment</code> simply takes a number <i>x</i>
                        as argument and returns <i>x + 1</i>
                    </li>
                    <li>
                        <code>double</code> is more interesting: its argument is
                        not a number but a function <i>f</i> with one argument.
                        <code>double</code> returns a function <i>g</i> such as
                        <i>g(x) = 2*f(x)</i>. Note that to return a function
                        from another function, you must use
                        <code>&lt;xu:copy-of&gt;</code> and not
                        <code>&lt;xu:value-of&gt;</code>.
                    </li>
                </ul>
                <p>
                    Finally we create a function
                    <code>incrementAndDouble</code> by applying
                    <code>double</code> on <code>increment</code>. As expected
                    the result of <code>incrementAndDouble(2)</code> is 6:
                </p>
                <xml-source>
                    <result>6</result>
                </xml-source>
            </section>
        </section>
    </body>
</document>
