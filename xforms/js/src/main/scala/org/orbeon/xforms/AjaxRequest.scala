/**
 * Copyright (C) 2019 Orbeon, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the
 * GNU Lesser General Public License as published by the Free Software Foundation; either version
 *  2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * The full text of the license is available at http://www.gnu.org/copyleft/lesser.html
 */
package org.orbeon.xforms

import java.{lang => jl}

import cats.data.NonEmptyList
import org.orbeon.oxf.util.MarkupUtils._
import org.orbeon.xforms.EventNames.XXFormsUploadProgress

import scala.scalajs.concurrent.JSExecutionContext.Implicits.queue


object AjaxRequest {

  private val Indent: String = " " * 4

  // NOTE: Later we can switch this to an automatically-generated protocol
  def buildXmlRequest(currentFormId: String, eventsToSend: NonEmptyList[AjaxEvent]): String = {

    val requestDocumentString = new jl.StringBuilder

    def newLine(): Unit = requestDocumentString.append('\n')
    def indent(l: Int): Unit = for (_ <- 0 to l) requestDocumentString.append(Indent)

    // Add entity declaration for nbsp. We are adding this as this entity is generated by the FCK editor.
    // The "unnecessary" concatenation is done to prevent IntelliJ from wrongly interpreting this
    requestDocumentString.append("""<!DOCTYPE xxf:event-request [<!ENTITY nbsp "&#160;">]>""")
    newLine()

    // Start request
    requestDocumentString.append("""<xxf:event-request xmlns:xxf="http://orbeon.org/oxf/xml/xforms">""")
    newLine()

    // Add form UUID
    indent(1)
    requestDocumentString.append("<xxf:uuid>")
    requestDocumentString.append(StateHandling.getFormUuid(currentFormId))
    requestDocumentString.append("</xxf:uuid>")
    newLine()

    val mustIncludeSequence =
      eventsToSend exists { event =>
        event.eventName != XXFormsUploadProgress && event.eventName != EventNames.XXFormsSessionHeartbeat
      }

    // Still send the element name even if empty as this is what the schema and server-side code expects
    indent(1)
    requestDocumentString.append("<xxf:sequence>")
    if (mustIncludeSequence) {

      val currentSequenceNumber = StateHandling.getSequence(currentFormId)
      requestDocumentString.append(currentSequenceNumber)

      // `require(EventQueue.ajaxRequestInProgress == false)`
      AjaxClient.ajaxResponseReceivedForCurrentEventQueueF("sequence number") foreach { _ =>
        // Increment sequence number, now that we know the server processed our request
        // If we were to do this after the request was processed, we might fail to increment the sequence
        // if we were unable to process the response (i.e. JS error). Doing this here, before the
        // response is processed, we incur the risk of incrementing the counter while the response is
        // garbage and in fact maybe wasn't even sent back by the server, but by a front-end.
        StateHandling.updateSequence(currentFormId, currentSequenceNumber.toInt + 1)
      }
    }
    requestDocumentString.append("</xxf:sequence>")
    newLine()

    // Keep track of the events we have handled, so we can later remove them from the queue

    // Start action
    indent(1)
    requestDocumentString.append("<xxf:action>")
    newLine()

    // Add events
    eventsToSend.toList foreach { event =>

      // Create `<xxf:event>` element
      indent(2)
      requestDocumentString.append("<xxf:event")
      requestDocumentString.append(s""" name="${event.eventName}"""")
      event.targetIdOpt. foreach { targetId =>
        requestDocumentString.append(s""" source-control-id="${Page.deNamespaceIdIfNeeded(currentFormId, targetId)}"""")
      }
      requestDocumentString.append(">")

      if (event.properties.nonEmpty) {
        // Only add properties when we don"t have a value (in the future, the value should be
        // sent in a sub-element, so both a value and properties can be sent for the same event)
        newLine()
        event.properties foreach { case (key, value) =>

          val stringValue = value.toString // support number and boolean

          indent(3)
          requestDocumentString.append(s"""<xxf:property name="${key.escapeXmlForAttribute}">""")
          requestDocumentString.append(stringValue.escapeXmlMinimal.removeInvalidXmlCharacters)
          requestDocumentString.append("</xxf:property>")
          newLine()
        }
        indent(2)
      }
      requestDocumentString.append("</xxf:event>")
      newLine()
    }

    // End action
    indent(1)
    requestDocumentString.append("</xxf:action>")
    newLine()

    // End request
    requestDocumentString.append("</xxf:event-request>")

    requestDocumentString.toString
  }
}
