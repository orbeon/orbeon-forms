<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
    Copyright (C) 2004 Orbeon, Inc.

    The Orbeon documentation is not distributed under the LGPL license. Use of the documentation is
    subject to the following terms:

    * Conversion to other formats is allowed, but the actual content may not be altered or edited
      in any way.

    * You may create printed copies for your own personal use.

    * For all other uses, such as selling printed copies or using (parts of) the manual in another
      publication, prior written agreement from Orbeon, Inc. is required.

    Please contact Orbeon at info@orbeon.com for more information.
-->
<document xmlns:p="http://www.orbeon.com/oxf/pipeline"
          xmlns:xforms="http://www.w3.org/2002/xforms"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <header>
        <title>Introduction to the XML Pipeline Definition Language (XPL)</title>
    </header>
    <body>
        <section>
            <title>Introduction</title>
            <p>
                The XML Pipeline Definition Language (XPL) is a powerful declarative language for
                processing XML using a pipeline metaphor. XML documents enter a pipeline, are
                efficiently processed by one or more processors as specified by XPL instructions,
                and are then output for further processing, display, or storage. XPL features
                advanced capabilities such as document aggregation, conditionals (“if” conditions),
                loops, schema validation, and sub-pipelines.
            </p>
            <p>
                XPL pipelines are built up from smaller components called XML processors or XML
                components. An XML processor is a software component which consumes and produces
                XML documents. New XML processors are most often written in Java. But most often
                developers do not need to write their own processors because OPS
                comes standard with a comprehensive library. XPL orchestrates these to create
                business logic, similar to the way Java code “orchestrates” method calls within a
                Java object.
            </p>
            <p>
                For a step-by-step introduction to pipelines, see the <link href="pages/OPS%20Tutorial.pdf"> OPS Tutorial</link>.
            </p>
            <p>
                Please also refer to the <a
                href="http://www.w3.org/Submission/2005/SUBM-xpl-20050411/">XPL 1.0 Submission at
                W3C</a>.
            </p>
        </section>
        <section>
            <title>XPL Interpreter</title>
            <p>
                The XPL interpreter is itself implemented as an XML processor, called the Pipeline
                processor. This processor reads a pipeline definition following the XPL syntax on
                its <code>config</code> input, and assembles a pipeline according to that
                definition. It is then able to run the pipeline when called.
            </p>
        </section>
        <section>
            <title>Namespace</title>
            <p>
                All the elements defined by XPL must be in the namespace with a URI:
                <code>http://www.orbeon.com/oxf/pipeline</code>. For consistency, XPL elements
                should use the <code>p</code> prefix. This document we will assumes that this prefix
                is used.
            </p>
        </section>
        <section>
            <title>&lt;p:config&gt; element</title>
            <p>
                The root element of a XPL document (<code>config</code>) defines:
            </p>
            <ul>
                <li>
                    Zero or more input or output parameters to the pipeline with <link
                    href="#param"> <code>&lt;p:param&gt;</code> </link>
                </li>
                <li>
                    The list of statements that need to executed for this pipeline. A statement
                    defines either a processor with its connections to other processors in the
                    pipeline using <link href="#processor"> <code>&lt;p:processor&gt;</code>
                    </link>, or a condition using <link href="#choose">
                    <code>&lt;p:choose&gt;</code></link>.
                </li>
            </ul>
            <p>
                The &lt;p:config&gt; element and its content are defined in the Relax NG schema
                with:
            </p>
            <xml-source>
                <start>
                    <ref name="config"/>
                </start>
                <define name="config">
                    <element name="p:config">
                        <optional>
                            <attribute name="id"/>
                        </optional>
                        <ref name="param"/>
                        <ref name="statement"/>
                    </element>
                </define>
                <define name="statement">
                    <interleave>
                        <zeroOrMore>
                            <ref name="processor"/>
                        </zeroOrMore>
                        <zeroOrMore>
                            <ref name="choose"/>
                        </zeroOrMore>
                        <zeroOrMore>
                            <ref name="for-each"/>
                        </zeroOrMore>
                    </interleave>
                </define>
            </xml-source>
        </section>
        <a name="param"/>
        <section>
            <title>&lt;p:param&gt; element</title>
            <p>
                The <code>&lt;p:param&gt;</code> element defines what the inputs and outputs of the
                pipeline are. Each input and output has a name. There cannot be two inputs with the
                same name or two outputs with the same name, but it is possible to have an output
                and an input with the same name. Every input name defines an id that can be later
                referenced with the <link href="#href-attribute"><code>href</code> attribute</link>
                such as when connecting processors. The output names can be referenced with the
                <code>ref</code> attribute on <link href="#processor"> <code>&lt;p:output&gt;</code>
                </link>.
            </p>
            <img print-format="pdf" src="pages/reference-xpl-pipelines-param.png"/>
            <p>
                The inputs and outputs of the above pipeline are declared in the XPL document
                below:
            </p>
            <xml-source>
                <p:config>
                    <p:param type="input" name="data"/>
                    <p:param type="input" name="foo"/>
                    <p:param type="output" name="bar"/>
                    <p:param type="output" name="data"/>
                </p:config>
            </xml-source>
            <p>
                The <code> &lt;p:param&gt; </code> element and its content are defined in the Relax
                NG schema with:
            </p>
            <xml-source>
                <define name="param">
                    <zeroOrMore>
                        <element name="p:param">
                            <interleave>
                                <attribute name="name"/>
                                <attribute name="type"/>
                            </interleave>
                        </element>
                    </zeroOrMore>
                </define>
            </xml-source>
        </section>

        <a name="processor"/>
        <section>
            <title>&lt;p:processor&gt; element</title>
            <p>
                The <code>&lt;p:processor&gt;</code> element places a processor in the pipeline and
                connects it to other processors, pipeline inputs, or pipeline outputs.
            </p>
            <ul>
                <li>
                    <p>
                        The kind of processor created is specified with the <code>name</code>
                        attribute, which is an XML qualified name. A qualified name is composed of
                        two parts:
                    </p>
                    <ul>
                        <li><b>A prefix:</b> The prefix is mapped to a URI defining a namespace.</li>
                        <li><b>A local name:</b> This name is a name in the namespace defined by the prefix.</li>
                    </ul>
                    <p>
                        This mechanism allows grouping related processors in a namespace. For
                        example, all the basic OPS processors are grouped in the
                        <code>http://www.orbeon.com/oxf/processors</code> namespace. This namespace
                        is typically mapped to the <code>oxf</code> prefix. Processors are then
                        referred to using names such as <code>oxf:xslt</code> or
                        <code>oxf:scope-serializer</code>.
                    </p>
                    <p>
                        The name maps to a processor factory. Processor factories are registered
                        through the <code>processors.xml</code> file described in <link
                        href="integration-packaging">Packaging and Deployment</link>.
                    </p>
                    <note>
                        <p>
                            For backward compatibility, the <code>uri</code> attribute is still
                            supported.
                        </p>
                    </note>
                </li>
                <li>
                    <p>
                        The <code>&lt;p:input&gt;</code> element connects the input of the processor
                        with the name specified with the <code>name</code> attribute to one of:
                    </p>
                    <ul>
                        <li>
                            an inline XML document embedded in the <code>&lt;p:input&gt;</code> element
                        </li>
                        <li>
                            an XML document obtained according to the <link href="#href-attribute">full
                            syntax of the <code>href</code> attribute</link>, for example:
                            <ul>
                                <li><code>href="#some-id"</code></li>
                                <li><code>href="oxf:/my-document.xml"</code></li>
                                <li><code>href="aggregate('document', #some-id,
                                oxf:/my-document.xml#xpointer(/*/*))"</code></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><p>
                    The <code>&lt;p:output&gt;</code> element defines an <code>id</code>
                    corresponding to that output with the <code>id</code> attribute or connects the
                    output to a pipeline output with the <code>ref</code> attribute.
                </p></li>
                <li><p>
                    Optionally, <code>&lt;p:input&gt;</code> and <code>&lt;p:output&gt;</code> can
                    have a <code>schema-href</code> or <code>schema-uri</code> attribute. Those
                    attributes specify a schema that is used by the Pipeline processor to validate
                    the corresponding input or output. <code>schema-href</code> references a
                    document using the <link href="#href-attribute"><code>href</code></link>
                    syntax. <code>schema-uri</code> specifies the URI of a schema that is mapped to
                    a specific schema in the <link href="reference-properties">OPS
                    properties file</link>.
                </p></li>
                <li><p>
                    Optionally, <code>&lt;p:input&gt;</code> and <code>&lt;p:output&gt;</code> can
                    have a <code>debug</code> attribute. When this attribute is present, the
                    document that passes through that input or output is logged with Log4J. This is
                    useful during development to watch XML documents going through the pipeline.
                </p></li>
            </ul>
            <p>
                The following example feeds an XSLT processor with an inline document and an
                external stylesheet.
            </p>
            <xml-source>
                <p:processor name="oxf:xslt">
                    <p:input name="config" href="stylesheet.xsl"/>
                    <p:input name="data" schema-href="oxf:/address-book-schema.xml">
                        <address-book>
                            <card>
                                <name>John Smith</name>
                                <email>js@example.com</email>
                            </card>
                            <card>
                                <name>Fred Bloggs</name>
                                <email>fb@example.net</email>
                            </card>
                        </address-book>
                    </p:input>
                    <p:output name="data" id="address-book"/>
                </p:processor>
            </xml-source>
            <p>
                The &lt;p:processor&gt; element and its content are defined in the Relax NG schema
                with:
            </p>
            <xml-source>
                <define name="processor">
                    <element name="p:processor">
                        <attribute name="name"/>
                        <interleave>
                            <zeroOrMore>
                                <element name="p:input">
                                    <attribute name="name"/>
                                    <ref name="debug"/>
                                    <ref name="schemas"/>
                                    <optional>
                                        <choice>
                                            <attribute name="href"/>
                                            <ref name="anyElement"/>
                                        </choice>
                                    </optional>
                                </element>
                            </zeroOrMore>
                            <zeroOrMore>
                                <element name="p:output">
                                    <attribute name="name"/>
                                    <ref name="schemas"/>
                                    <ref name="debug"/>
                                    <choice>
                                        <attribute name="id"/>
                                        <attribute name="ref"/>
                                    </choice>
                                </element>
                            </zeroOrMore>
                        </interleave>
                    </element>
                </define>
            </xml-source>
        </section>
        <a name="choose"/>
        <section>
            <title>&lt;p:choose&gt; element</title>
            <p>
                The <code>&lt;p:choose&gt;</code> element can be used to execute different
                processors depending on a specific condition. The general syntax for this is very
                close to XSLT:
            </p>
            <xml-source>
                <p:choose href="#condition-document">
                    <p:when test="first-condition">...</p:when>
                    <p:when test="second-condition">...</p:when>
                    <p:otherwise>...</p:otherwise>
                </p:choose>
            </xml-source>
            <p>
                The conditions are expressed in XPath and operate on the XML document specified by
                the <code>href</code> attribute on <code>p:choose</code>. Each branch can contain
                regular processor declarations as well as nested conditions.
            </p>
            <p>
                Outputs declared in a branch are subject to the following conditions:
            </p>
            <ul>
                <li>
                    An output id cannot override an output id in scope before the corresponding
                    <code>choose</code> element
                </li>
                <li>
                    The scope of an output <code>id</code> is local to the branch if it is
                    connected inside that branch
                </li>

                <li>
                    The set of output ids not connected inside a branch become visible to
                    processors declared after the corresponding <code>choose</code> element
                </li>
                <li>
                    The set of output ids not connected inside the branch must be consistent among
                    all branches
                </li>
            </ul>
            <p>
                The last condition means that if a branch has two non-connected outputs such as
                output1 and output2, then all other branches must declare the same outputs. On the
                other hand, inputs in branches do not have to refer to the same outputs.
            </p>
            <p>
                The <code>&lt;p:choose&gt;</code> element and its content are defined in the Relax
                NG schema with:
            </p>
            <xml-source>
                <define name="choose">
                    <element name="p:choose">
                        <attribute name="href"/>
                        <oneOrMore>
                            <element name="p:when">
                                <attribute name="test"/>
                                <ref name="statement"/>
                            </element>
                        </oneOrMore>
                        <optional>
                            <element name="p:otherwise">
                                <ref name="statement"/>
                            </element>
                        </optional>
                    </element>
                </define>
            </xml-source>
        </section>
        <a name="for-each"/>
        <section>
            <title>&lt;p:for-each&gt; element</title>
            <p>
                With <code>&lt;for-each&gt;</code> you can execute processors multiple times based
                on the content of a document. Consider this example: an XML document contains
                information about employees, each described in an <code>emp</code> element. This
                document is stored in a file called <code>company.xml</code>:
            </p>
            <xml-source>
                <company>
                    <emp>
                        <firstname>John</firstname>
                        <lastname>Smith</lastname>
                    </emp>
                    <emp>
                        <firstname>Judy</firstname>
                        <lastname>Matthews</lastname>
                    </emp>
                    <emp>
                        <firstname>Gloria</firstname>
                        <lastname>Schwartz</lastname>
                    </emp>
                </company>
            </xml-source>
            <p>
                You want to apply a stylesheet (stored in <code>transform-employee.xsl</code>) to
                each employee. You can do this with the following pipeline:
            </p>
            <xml-source>
                <p:config xmlns:p="http://www.orbeon.com/oxf/pipeline">
                    <p:for-each href="company.xml" select="/company/emp" root="new-company" id="company-out">
                        <p:processor name="oxf:xslt">
                            <p:input name="data" href="current()"/>
                            <p:input name="config" href="transform-employee.xsl"/>
                            <p:output name="data" ref="company-out"/>
                        </p:processor>
                    </p:for-each>
                    <comment>The id "company-out" can now be referenced by other</comment>
                    <comment>processor in the pipeline.</comment>
                </p:config>
            </xml-source>
            <p>
                This diagram describes how the iteration is done in the above example:
            </p>
            <img print-format="pdf" src="pages/reference-xpl-pipelines-for-each.png"/>
            <ul>
                <li>
                    In a <code>&lt;for-each&gt;</code> you can have multiple processors connected
                    together, <code>&lt;choose&gt;</code> statements and nested
                    <code>&lt;for-each&gt;</code>, just like outside of a
                    <code>&lt;for-each&gt;</code>.
                </li>
                <li>
                    The output of a processor (or other <code>&lt;for-each&gt;</code>) inside the
                    <code>&lt;for-each&gt;</code> must be "connected to the for-each" using a
                    <code>ref="..."</code> attribute. The value in the <code>ref</code> attribute
                    must match the value of the <code>&lt;for-each&gt;</code> <code>id</code>
                    attribute.
                </li>
                <li>
                    You access the current part of the XML document being iterated with
                    <code>current()</code> in an href expression. If you have nested
                    <code>&lt;for-each&gt;</code>, <code>current()</code> applies to the
                    <code>&lt;for-each&gt;</code> that directly includes the <code>current()</code>
                    expression.
                </li>
                <li>
                    The processor inside a <code>&lt;for-each&gt;</code> can access ids declared
                    before the <code>&lt;for-each&gt;</code> statement.
                </li>
                <li>
                    The aggregated document (the "output of the <code>&lt;for-each&gt;</code>") is
                    available in the rest of the pipeline with the <code>id</code> declared in the
                    <code>id</code> attribute. Alternatively, you can directly connect the output
                    of the <code>&lt;for-each&gt;</code> to an output of the current pipeline with a
                    <code>ref</code> attribute (as in the processor <code>&lt;output&gt;</code>
                    element). If the <code>ref</code> attribute is used (instead of
                    <code>id</code>), then the value of the <code>ref</code> must be referenced
                    (instead of the value of the <code>id</code> attribute). When both the
                    <code>id</code> and <code>ref</code> attributes are used, the value of the
                    <code>id</code> attribute must be referenced.
                </li>
                <li>
                    The <code>&lt;for-each&gt;</code> can have optional attributes:
                    <code>input-debug</code>, <code>input-schema-href</code>,
                    <code>input-schema-uri</code>, <code>output-debug</code>,
                    <code>output-schema-href</code> and <code>output-schema-uri</code>. The
                    attributes starting with "<code>input</code>" (respectively
                    "<code>output</code>") work as the similar attributes, just without the prefix,
                    on the <code>&lt;input&gt;</code> element (respectively
                    <code>&lt;output&gt;</code> element). The attributes starting with
                    "<code>input</code>" apply to the document referenced by the <code>href</code>
                    expression. The attributes starting with "<code>output</code>" apply to the
                    output of the <code>&lt;for-each&gt;</code>.
                </li>
            </ul>
        </section>
        <a name="href-attribute"/>
        <section>
            <title>href attribute</title>
            <p>
                The <code>href</code> attribute is used to:
            </p>
            <ul>
                <li>Reference external documents</li>
                <li>Refer outputs of other processors</li>
                <li>Aggregate documents using the aggregate() function</li>
                <li>Select part of a document using XPointer</li>
            </ul>
            <p>
                The complete syntax of the <code>href</code> attribute is
                described below in a Backus Nauer Form (BNF)-like syntax:
            </p>
            <source>
    href              ::= ( local_reference | uri | aggregation ) [ xpointer ]
    local_reference   ::= "#" id
    aggregation       ::= "aggregate(" root_element_name "," agg_parameter ")"
    root_element_name ::= "'"  name "'"
    agg_parameter     ::= href [ "," agg_parameter ]
    xpointer          ::= "#xpointer(" xpath_expression ")"</source>
            <section>
                <title>URI</title>
                <p>
                    The URI syntax is defined in RFC 2396. A URI is used to references an external
                    document. A URI can be:
                </p>
                <ul>
                    <li>
                        Absolute, if a protocol is specified. For instance
                        <code>file:/dir/file.xml</code>.
                    </li>
                    <li>
                        Relative, if no protocol is specified. For instance
                        <code>../file.xml</code>. The document is loaded relatively to the URL of
                        the XPL document where the <code>href</code> is declared, as specified in
                        RFC 1808.
                    </li>
                </ul>
            </section>
            <section>
                <title>Aggregation</title>
                <p>
                    Multiple documents can be aggregated with the <code>aggregate()</code> function.
                    The name of the root element that will contain the aggregated document is
                    specified in the first argument. The documents to aggregate are specified in the
                    following arguments. There is no restriction on the number of documents that
                    can be aggregated.
                </p>
                <p>
                    For example, you have a document (with output id
                    <code>first</code>):
                </p>
                <xml-source>
                    <employee>John</employee>
                </xml-source>
                <p>And a second document (with output id
                    <code>second</code>):</p>
                <xml-source>
                    <employee>Marc</employee>
                </xml-source>
                <p>
                    Those two documents can be aggregated using <code>aggregate('employees',
                    #first,
                    #second)</code>. This produces the following document:
                </p>
                <xml-source>
                    <employees>
                        <employee>John</employee>
                        <employee>Marc</employee>
                    </employees>
                </xml-source>
            </section>
            <section>
                <title>XPointer</title>
                <p>
                    The XPointer syntax is used to select parts of a document. For example, if you
                    have a document in a file called <code>company.xml</code>:
                </p>
                <xml-source>
                    <company>
                        <name>Orbeon</name>
                        <site>
                            <web>http://www.orbeon.com/</web>
                            <ftp>ftp://ftp.orbeon.com/</ftp>
                        </site>
                    </company>
                </xml-source>
                <p>
                    The expression <code>company.xml#xpointer(/company/site)</code> produces the
                    document:
                </p>
                <xml-source>
                    <site>
                        <web>http://www.orbeon.com/</web>
                        <ftp>ftp://ftp.orbeon.com/</ftp>
                    </site>
                </xml-source>
            </section>
            <section>
                <title>Multiple References to an Identifier</title>
                <p>
                    The same id may be referenced multiple times in the same XPL document. For
                    example, the <code>id doc</code> is referenced by two processors in the
                    following example:
                </p>
                <xml-source>
                    <p:config xmlns:p="http://www.orbeon.com/oxf/pipeline">
                        <p:processor uri="A">
                            <p:output name="data" id="doc"/>
                        </p:processor>
                        <p:processor uri="B">
                            <p:input name="data" href="#doc"/>
                        </p:processor>
                        <p:processor uri="C">
                            <p:input name="data" href="#doc"/>
                        </p:processor>
                    </p:config>
                </xml-source>
                <p>
                    The document seen by B and C are identical. This situation can be graphically
                    represented as:
                </p>
                <img print-format="pdf" src="pages/reference-xpl-pipelines-tee.png"/>
            </section>
        </section>
        <section>
            <title>Processor Inputs and Outputs</title>
            <section>
                <title>Declared Inputs and Outputs</title>
                <p>
                    XPL processors declare a certain number of inputs and outputs. Those inputs and
                    outputs constitute the <i>interface</i> of the processor, in the same way that
                    methods in object-oriented programming languages like Java expose parameters.
                    For example, the XSLT processor expects:
                </p>
                <ul>
                    <li>a <code>config</code> input receiving an XSLT stylesheet definition</li>
                    <li>a <code>data</code> input receiving the XML document to transform</li>
                    <li>a <code>data</code> output producing the transformed XML document</li>
                </ul>
                <p>
                    You know what inputs and outputs to connect for a given processor by consulting
                    the documentation for that processor. This is similar to looking up a method
                    signature in an object-oriented programming language.
                </p>
            </section>
            <section>
                <title>Connecting Inputs and Outputs</title>
                <p>
                    Consider the following XSLT processor instance in a pipeline:
                </p>
                <xml-source>
                    <p:processor name="oxf:xslt">
                        <p:input name="config" href="stylesheet.xsl"/>
                        <p:input name="data" schema-href="oxf:/address-book-schema.xml">
                            <address-book>
                                <card>
                                    <name>John Smith</name>
                                    <email>js@example.com</email>
                                </card>
                                <card>
                                    <name>Fred Bloggs</name>
                                    <email>fb@example.net</email>
                                </card>
                            </address-book>
                        </p:input>
                        <p:output name="data" id="address-book"/>
                    </p:processor>
                </xml-source>
                <p>
                    Both its <code>config</code> and <code>data</code> inputs are said to be
                    connected, because the <code>&lt;p:processor></code> element for the XSLT
                    processor has <code>&lt;p:input></code> elements for both those inputs, and they
                    each refer to an XML document:
                </p>
                <ul>
                    <li>In the first case, a resource called <code>stylesheet.xsl</code></li>
                    <li>In the second case, an inline document with root element <code>address-book</code></li>
                </ul>
                <p>
                    There are other ways to connect inputs, for example:
                </p>
                <xml-source>
                    <p:config>
                        <comment> Pipeline input called "my-input" </comment>
                        <p:param name="my-input" type="input"/>
                        <comment> First XSLT transformation </comment>
                        <p:processor name="oxf:xslt">
                            <p:input name="config" href="stylesheet-1.xsl"/>
                            <p:input name="data" href="#my-input"/>
                            <p:output name="data" id="address-book"/>
                        </p:processor>
                        <comment> Second XSLT transformation </comment>
                        <p:processor name="oxf:xslt">
                            <p:input name="config" href="stylesheet-2.xsl"/>
                            <p:input name="data" href="#address-book"/>
                            <p:output name="data" id="phone-list"/>
                        </p:processor>
                        <comment> ... </comment>
                    </p:config>
                </xml-source>
                <p>
                    In this case:
                </p>
                <ul>
                    <li>
                        The <code>data</code> input of the first XSLT processor instance is
                        connected to the <code>my-input</code> input of the pipeline.
                    </li>
                    <li>
                        The <code>data</code> input of the second XSLT processor instance is
                        connected to the <code>address-book</code> output of the first XSLT
                        processor instance.
                    </li>
                </ul>
                <p>
                    The example above shows that the <code>address-book</code> output of the first
                    XSLT processor instance is connected to the input of a following processor. A
                    processor output can also be connected to a pipeline output, as follows:
                </p>
                <xml-source>
                    <p:config>
                        <comment> Pipeline input called "my-input" </comment>
                        <p:param name="my-input" type="input"/>
                        <comment> Pipeline output called "my-output" </comment>
                        <p:param name="my-output" type="output"/>
                        <comment> XSLT transformation </comment>
                        <p:processor name="oxf:xslt">
                            <p:input name="config" href="stylesheet-1.xsl"/>
                            <p:input name="data" href="#my-input"/>
                            <p:output name="data" ref="my-output"/>
                        </p:processor>
                    </p:config>
                </xml-source>
                <p>
                    In this case, the <code>data</code> output of the XSLT processor is connected to
                    the <code>my-output</code> output of the containing pipeline.
                </p>
                <p>
                    To sum up, a processor input can be connected to:
                </p>
                <ul>
                    <li>a resource XML document</li>
                    <li>an inline XML document</li>
                    <li>the output of another processor</li>
                    <li>a pipeline input</li>
                    <li>a combination of the above through the <link href="#href-attribute">full
                    syntax of the <code>href</code> attribute</link></li>
                </ul>
                <p>
                    A processor output can be connected to:
                </p>
                <ul>
                    <li>the input of another processor with the <code>id</code> attribute</li>
                    <li>a pipeline output with the <code>ref</code> attribute</li>
                </ul>
            </section>
            <a name="optional"/>
            <section>
                <title>Mandatory and Optional Inputs and Outputs</title>
                <p>
                    Some inputs and outputs are <i>required</i> by a processor. This means that you
                    have to declare <code>&lt;p:input></code> and <code>&lt;p:output></code>
                    elements with the appropriate <code>name</code> attribute within the
                    <code>&lt;p:processor></code> element corresponding to that processor, and to
                    connect those inputs and outputs as discussed in the previous section. Most
                    processors require all their inputs and outputs to be connected.
                </p>
                <p>
                    Some processors on the other hand may declare some inputs and outputs as
                    <i>optional</i>. This means that the user of the processor may or may not
                    connect an input or output if it is not necessary to do so. For example, the SQL
                    processor declares an optional <code>datasource</code> input. If the
                    <code>datasource</code> input is needed by the user, it must be connected:
                </p>
                <xml-source>
                    <p:processor name="oxf:sql">
                        <p:input name="datasource" href="my-datasource.xml"/>
                        <p:input name="data" href="#some-data"/>
                        <p:input name="config">
                            <config>
                                ...
                            </config>
                        </p:input>
                    </p:processor>
                </xml-source>
                <p>
                    On the other hand, if the user of the SQL processor does not require an
                    external datasource document, she can simply not connect the
                    <code>datasource</code> input:
                </p>
                <xml-source>
                    <p:processor name="oxf:sql">
                        <p:input name="data" href="#some-data"/>
                        <p:input name="config">
                            <config>
                                ...
                            </config>
                        </p:input>
                    </p:processor>
                </xml-source>
                <p>
                    It is entirely up to each processor to determine which inputs and outputs are
                    mandatory or optional, and how and when they are read.
                </p>
                <p>
                    Note that a processor may decide whether an input must be connected depending on
                    the content of other inputs, for example the SQL processor does not require the
                    <code>datasource</code> input if its <code>config</code> input already refers to
                    a J2EE datasource. On the contrary, if it does not refer to such a datasource,
                    it requires the <code>datasource</code> input to be connected. If it is not,
                    the processor generates an error at runtime.
                </p>
            </section>
            <section>
                <title>Referring to Inputs and Outputs with URIs</title>
                <p>
                    In certain cases, the user of a processor must refer, from a processor
                    configuration, to particular processor inputs and outputs. If you implement a
                    new processor, you should support the <code>input:</code> and
                    <code>output:</code> URI schemes for this purpose. On the other hand, if you are
                    using a standard OPS processor supporting such references to
                    processor inputs and outputs, you can count on the <code>input:</code> and
                    <code>output:</code> URI schemes being used. For example:
                </p>
                <ul>
                    <li>To refer to a processor input named <code>my-input</code>, use the URI: <code>input:my-input</code></li>
                    <li>To refer to a processor output named <code>my-output</code>, use the URI: <code>output:my-output</code></li>
                </ul>
                <p>
                    While there is no requirement for processor configurations to follow this URI
                    convention, it is highly recommended to do so whenever possible to ensure
                    consistency. In OPS, several processors make use of it,
                    including:
                </p>
                <ul>
                    <li>The XSLT processor</li>
                    <li>The XUpdate processor</li>
                    <li>The Email processor</li>
                </ul>
                <p>
                    For concrete examples, please refer to the <a
                    href="processors-xslt#user-defined">XSLT processor</a> or the <a
                    href="processors-messaging-email#out-of-line-parts">Email processor</a>
                    documentation.
                </p>
                <p>
                    Currently, no standard processor within OPS makes uses of the
                    <code>output:</code> scheme. The XSLT processor would be a good candidate for
                    this feature, with XSLT 2.0's support for multiple output documents.
                </p>
            </section>
        </section>
    </body>
</document>
