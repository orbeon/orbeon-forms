<!--
  Copyright (C) 2012 Orbeon, Inc.

  This program is free software; you can redistribute it and/or modify it under the terms of the
  GNU Lesser General Public License as published by the Free Software Foundation; either version
  2.1 of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  The full text of the license is available at http://www.gnu.org/copyleft/lesser.html
  -->
<xf:model
    id="fr-persistence-model"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xf="http://www.w3.org/2002/xforms"
    xmlns:xxf="http://orbeon.org/oxf/xml/xforms"
    xmlns:saxon="http://saxon.sf.net/"
    xmlns:fr="http://orbeon.org/oxf/xml/form-runner"
    xmlns:frf="java:org.orbeon.oxf.fr.FormRunner"
    xmlns:secure="java:org.orbeon.oxf.util.SecureUtils"
    xmlns:grid-migration="java:org.orbeon.oxf.fr.GridDataMigration"
    xmlns:simple-migration="java:org.orbeon.oxf.fr.SimpleDataMigration"
    xmlns:d="DAV:">

    <xf:var name="parameters"           value="xxf:instance('fr-parameters-instance')"/>
    <xf:var name="app"                  value="fr:app-name()"/>
    <xf:var name="form"                 value="fr:form-name()"/>
    <xf:var name="form-version"         value="fr:form-version()"/>
    <xf:var name="document-element"     value="$parameters/document"/>
    <xf:var name="document"             value="$document-element/string()"/>
    <xf:var name="mode"                 value="fr:mode()"/>
    <xf:var name="is-fb"                value="fr:is-design-time()"/>

    <xf:var name="persistence-instance" value="instance('fr-persistence-instance')"/>
    <xf:var name="autosave-elem"        value="$persistence-instance/autosave"/>
    <xf:var name="lease-enabled-elem"   value="$persistence-instance/lease-enabled"/>
    <xf:var name="lease-state-elem"     value="$persistence-instance/lease-state"/>
    <xf:var name="lease-duration-elem"  value="$persistence-instance/lease-duration"/>

    <xf:var
        name="autosave-delay"
        value="
            for $d in xxf:property(string-join(('oxf.fr.detail.autosave-delay', $app, $form), '.'))
            return xs:integer($d[. castable as xs:integer])"/>

    <xf:var
        name="is-background"
        value="
            fr:is-background() and
            (: PE only :)
            (fr:is-pe() or frf:sendError(404))"/>

    <!-- Crude way of detecting export, might have to fix later! -->
    <xf:var
        name="is-export"
        value="$is-background and xxf:get-request-method() = 'GET'"/>

    <!-- Autosave disabled with Form Builder, see https://github.com/orbeon/orbeon-forms/issues/1169 -->
    <xf:var
        name="autosave-enabled"
        value="
            frf:isAutosaveSupported($app, $form)                                and
            not($is-background)                                                 and
            $autosave-delay gt 0                                                and
            xxf:non-blank(xxf:username())                                       and
            (: In the `new` mode, don't autosave if users can't edit data,
               as subsequent autosaves update data, and thus would fail for
               users who don't have the `update` permission :)
            (
                $mode != 'new' or
                frf:allAuthorizedOperationsAssumingOwnerGroupMember(
                    xxf:instance('fr-form-metadata')/permissions,
                    $app,
                    $form
                ) = ('*', 'update')
            )                                                                   and
            $mode = ('new', 'edit')                                             and
            not($is-fb)"/>

    <!-- NOTE: This value is only valid during form initialization, because the request attribute won't be present in
         subsequent updates. -->
    <xf:var
        name="is-submit"
        value="
            exists(xxf:get-request-attribute('fr-form-data')) or
            xxf:get-request-method() = 'POST' and exists(xxf:get-request-parameter('fr-form-data'))
        "/>

    <!--
        Running *before* the data is ready. At this point:
        - all instances are created (`xforms-model-construct`)
        - RRR has been done on all models except `fr-form-model`
        - other initializations upon `xforms-model-construct-done` have not yet been done
    -->
    <xf:action event="xxforms-instances-ready" observer="fr-form-model">

        <!-- For new documents, see if we have drafts -->
        <xf:action if="$mode = 'new'">

            <xf:var name="is-singleton" value="xxf:instance('fr-form-metadata')/singleton = 'true'"/>

            <xf:action if="$is-singleton">

                <!-- Is there any data for this form that the user can edit? -->
                <xf:setvalue context="instance('fr-search-request')/drafts" value="'include'"/>
                <xf:send submission="fr-search-submission"/>
                <xf:var name="existing-docs" value="instance('fr-search-response')/document"/>

                <xf:action if="count($existing-docs) = 1">
                    <xf:load resource="edit/{$existing-docs/@name}"/>
                </xf:action>
                <xf:action if="count($existing-docs) > 1">
                    <xf:setvalue
                        ref="instance('fr-persistence-instance')/found-document-message-to-show"
                        value="'found-multiple-docs-for-singleton'"/>
                </xf:action>

            </xf:action>

            <xf:action if="not($is-singleton) and not($is-submit)"><!-- https://github.com/orbeon/orbeon-forms/issues/4546 -->

                <!-- Do we have updatable drafts for documents that were never saved? -->
                <xf:action if="$autosave-enabled">
                    <xf:insert
                        context="instance('fr-search-request')"
                        origin="
                            xf:element('drafts', (xf:attribute('for-never-saved-document', 'true'), 'only')),
                            xf:element('operations', xf:attribute('any-of', 'update'))
                        "/>
                    <xf:send  submission="fr-search-submission"/>
                    <xf:var name="drafts-found" value="count(instance('fr-search-response')/document)"/>

                    <!-- Remember to show the dialog upon xforms-ready -->
                    <xf:setvalue
                        if="$drafts-found > 0"
                        ref="instance('fr-persistence-instance')/found-document-message-to-show"
                        value="if ($drafts-found = 1) then 'found-draft-for-never-saved' else 'found-drafts-for-never-saved'"/>
                </xf:action>

            </xf:action>

        </xf:action>

        <xf:dispatch
            if="xxf:is-blank(instance('fr-persistence-instance')/found-document-message-to-show)"
            name="fr-run-form-load-action-before-data"
            targetid="fr-form-model"/>

    </xf:action>

    <!-- 1. Model initialization when we have a specific app and form -->
    <xf:action
        event="xforms-model-construct-done"
        if="not($mode = ('summary', 'home', 'landing')) and $app != '*' and $form != '*'">

        <!-- Handle loading of initial data for new/test/edit/view/pdf/email modes only -->
        <xf:action if="$mode = ('new', 'test', 'edit') or fr:is-readonly-mode()">

            <xf:var name="is-new-id" value="xxf:is-blank($document)"/>
            <xf:var name="is-xml-submit" value="$is-submit and exists(xxf:get-request-attribute('fr-form-data'))"/>

            <!-- Create random document id if none is provided. This is the default for 'new', but a missing id is also
                 allowed for 'edit', 'view', etc., when data is posted to the page. -->
            <xf:setvalue if="$is-new-id" ref="$document-element" value="secure:randomHexId()"/>

            <!-- Case of 'new' mode where we load the initial data via a service -->
            <xf:var
                name="new-from-service"
                value="$mode = ('new', 'test') and xxf:property(string-join(('oxf.fr.detail.new.service.enable', $app, $form), '.'))"/>

            <xf:action if="$new-from-service">
                <xf:message level="xxf:log-debug">Loading new data from service</xf:message>
                <xf:send submission="fr-get-instance-from-service"/>
            </xf:action>

            <xf:message level="xxf:log-debug">
                $mode:                <xf:output value="$mode"/>
                $is-new-id:           <xf:output value="$is-new-id"/>
                $is-xml-submit:       <xf:output value="$is-xml-submit"/>
                $is-submit:           <xf:output value="$is-submit"/>
                $new-from-service:    <xf:output value="$new-from-service"/>
                $data-format-version: <xf:output value="xxf:get-request-parameter('data-format-version')"/>
            </xf:message>

            <!-- Keep initial data for clear button. We can argue if we would like instead to keep data submitted to
                `/new` below. Here seems to be a good start. -->
            <!-- Q: What about `fr-get-instance-from-service` above? -->
            <xf:insert
                ref="instance('fr-initial-instance')"
                origin="xxf:instance('fr-form-instance')"/>

            <!-- NOTE: We used to do a sort of permission check here for submits. Since #75 is implemented and there is
                 a proper authorization mechanism, this check is no longer required. -->

            <xf:action if="$is-submit">

                <xf:var
                    name="form-data"
                    value="
                        if ($is-xml-submit) then
                            xxf:get-request-attribute('fr-form-data')
                        else
                            frf:decodeSubmittedFormData(string(xxf:get-request-parameter('fr-form-data')))"/>

                <xf:message level="xxf:log-debug">Loading data submitted to the page</xf:message>

                <xf:insert
                    context="xxf:instance('fr-form-instance')/root()"
                    origin="
                        let $format-migrated :=
                            grid-migration:dataMigratedToEdge(
                                $app,
                                $form,
                                $form-data,
                                xxf:instance('fr-form-metadata')/root(),
                                xxf:get-request-parameter('data-format-version')
                            )/root()/*,
                        $simply-migrated :=
                            simple-migration:dataMaybeWithSimpleMigrationWithBehavior(
                                xxf:absolute-id('fr-form-model'),
                                instance('fr-initial-instance'),
                                $format-migrated,
                                (xxf:get-request-parameter('data-migration-behavior'), 'holesonly')[1]
                            )
                        return
                            if (exists($simply-migrated)) then
                                $simply-migrated
                            else
                                $format-migrated
                    "/>

                <!-- Be consistent with `fr-get-document-submission` -->
                <xf:delete
                    ref="xxf:instance('fr-form-instance')//(@xxf:relevant, @fr:relevant)"/>

                <!-- Set initial data as dirty, because this is the case typically of switching between script/noscript
                     mode, and we can't really know if the data is clean or dirty but would like to enable the save button -->
                <xf:setvalue
                    if="$mode = 'edit'"
                    ref="$persistence-instance/initial-data-status">dirty</xf:setvalue>
            </xf:action>

            <!-- In 'new' mode only, after an external document has been set, recalculate defaults (and rebuild so the refs
                 in the binds are updated). -->
            <xf:action if="$mode = ('new', 'test') and ($new-from-service or $is-submit)">
                <!-- After we get the document from the persistence layer, recalculate defaults (and rebuild so the refs
                     in the binds are updated).

                     2020-05-19: Confirming that upon XML POST, we want initial values to be evaluated.
                     Use case: POSTing current form data to `/new` and clearing some fields only. -->
                <xf:message level="xxf:log-debug">Updating initial values for externally-loaded new document</xf:message>
                <xf:rebuild model="fr-form-model"/>
                <xf:recalculate xxf:defaults="true" model="fr-form-model"/>
            </xf:action>

            <!-- Case of modes other than new where the data to be edited or viewed is loaded from the persistence layer -->
            <xf:action if="not($mode = ('new', 'test')) and not($is-new-id) and not($is-submit)">

                <xf:var
                    name="lease-enabled"
                    value="
                        xxf:property(string-join(('oxf.fr.detail.lease.enabled', $app, $form), '.')) and
                        frf:isLeaseSupported($app, $form) and
                        not(fr:is-readonly-mode())        and
                        not($is-background)               and
                        not(fr:is-browser-environment())  and
                        not(fr:is-embedded()) (: Q: Should we consider enabling this with portlet embedding? :)
                    "/>
                <xf:setvalue ref="$lease-enabled-elem" value="$lease-enabled"/>
                <xf:action if="$lease-enabled">

                    <!-- If the lease feature is enabled but we have no user information, issue a 403 -->
                    <xf:action if="xxf:is-blank(xxf:username())" type="xpath">
                        frf:sendError(403)
                    </xf:action>

                    <!-- Keep track of user, lease duration, and thresholds -->
                    <xf:setvalue ref="instance('fr-lockinfo-request')/d:owner/fr:username" value="xxf:username()"/>
                    <xf:setvalue
                        ref="$lease-duration-elem"
                        value="xxf:property(string-join(('oxf.fr.detail.lease.duration.*', $app, $form), '.'))"/>
                    <xf:action iterate="frf:xpathOrbeonRolesFromCurrentRequest()">
                        <xf:var name="role" value="."/>
                        <xf:var
                            name="role-duration"
                            value="xxf:property(string-join(('oxf.fr.detail.lease.duration', $role, $app, $form), '.'))"/>
                        <xf:setvalue
                            if="$role-duration > $lease-duration-elem"
                            ref="$lease-duration-elem"
                            value="$role-duration"/>
                    </xf:action>
                    <xf:setvalue
                        ref="$persistence-instance/lease-renew-threshold"
                        value="xxf:property(string-join(('oxf.fr.detail.lease.renew-threshold', $app, $form), '.'))"/>
                    <xf:setvalue
                        ref="$persistence-instance/lease-alert-threshold"
                        value="xxf:property(string-join(('oxf.fr.detail.lease.alert-threshold', $app, $form), '.'))"/>
                    <xf:setvalue ref="$persistence-instance/lease-load-document">true</xf:setvalue>
                    <xf:send submission="fr-acquire-lease-submission"/>
                </xf:action>

                <xf:action if="not($lease-enabled)">
                    <xf:dispatch name="fr-load-document" target="fr-persistence-model"/>
                </xf:action>
            </xf:action>

            <!-- Don't allow if we didn't get a submit and we don't have the proper id depending on the mode

                 NOTE: 403 applies well to the first condition. For the second condition, a 404 could also be possible.
             -->
            <xf:action if="not($is-submit) and not($is-new-id and $mode = ('new', 'test') or not($mode = ('new', 'test')))" type="xpath">
                frf:sendError(403)
            </xf:action>
        </xf:action>

        <!-- Notify that the data is ready -->
        <xf:dispatch targetid="fr-form-model" name="fr-data-ready"/>

    </xf:action>

    <xf:action event="fr-load-document">
        <!-- Load document with the provided id from persistence layer -->
        <xf:message level="xxf:log-debug">Loading data by id from persistence layer: <xf:output value="$document"/></xf:message>
        <xf:var name="draft-requested" value="xxf:get-request-parameter('draft') = 'true'"/>
        <xf:action if="$draft-requested">
            <xf:send submission="fr-get-document-submission">
                <xf:property name="data-or-draft" value="'draft'"/>
            </xf:send>
        </xf:action>
        <xf:action if="not($draft-requested)">
            <xf:insert
                context="instance('fr-search-request')"
                origin="
                    xf:element('drafts', (xf:attribute('for-document-id', $document), 'only')),
                    xf:element('operations', xf:attribute('any-of', 'update'))
                "/>
            <xf:send if="$autosave-enabled" submission="fr-search-submission"/>
            <xf:var name="draft-found" value="exists(instance('fr-search-response')/document)"/>

            <!-- Remember to show the dialog upon xforms-ready -->
            <xf:setvalue
                if="$draft-found"
                ref="instance('fr-persistence-instance')/found-document-message-to-show"
                value="'found-draft-for-document'"/>

            <!-- Otherwise just load the data -->
            <xf:send if="not($draft-found)" submission="fr-get-document-submission">
                <xf:property name="data-or-draft" value="'data'"/>
            </xf:send>
        </xf:action>
    </xf:action>

    <!-- 2. Check form availability based on form metadata -->
    <!-- Do this here as we need fr-form-model to be initialized. -->
    <xf:action
        event="xforms-ready"
        if="xxf:instance('fr-form-metadata')/available = 'false'"
        type="xpath">frf:sendError(404)</xf:action>

    <!-- 3. Maybe show drafts dialog and check form permissions for detail modes -->
    <xf:action event="xforms-ready" if="not($mode = ('summary', 'home', 'landing'))">

        <xf:var name="show-drafts-dialog" value="instance('fr-persistence-instance')/found-document-message-to-show != ''"/>
        <xf:action if="not($show-drafts-dialog)">
            <xf:dispatch name="fr-compute-authorized-operations" target="fr-persistence-model"/>
        </xf:action>
    </xf:action>

    <xf:action
        observer="fr-persistence-model"
        event="fr-compute-authorized-operations">

        <xf:var name="from-persistence" value="instance('fr-authorized-operations')/@from-persistence"/>
        <xf:var name="ops" value="
                if (exists($from-persistence)) then
                   xxf:split($from-persistence)
                else if ($mode = 'new') then
                   frf:allAuthorizedOperationsAssumingOwnerGroupMember(xxf:instance('fr-form-metadata')/permissions, $app, $form)
                else
                   frf:authorizedOperationsBasedOnRolesXPath          (xxf:instance('fr-form-metadata')/permissions, $app, $form)
            "/>

        <xf:setvalue
            ref="instance('fr-authorized-operations')"
            value="string-join($ops, ' ')"/>

        <xf:message level="xxf:log-debug">
            AUTHORIZED OPERATIONS ON FORM (DETAIL MODES): <xf:output value="instance('fr-authorized-operations')"/>
        </xf:message>

        <!-- Send an "Unauthorized" error if the user is unauthorized -->
        <xf:action
            if="not(
                frf:isUserAuthorizedBasedOnOperationsAndModeXPath(
                    $ops,
                    $mode,
                    $is-submit
                )
            )"
            type="xpath">frf:sendError(403)</xf:action>

    </xf:action>

    <!-- Instance for background service response -->
    <xf:instance
        id="fr-background-response-instance"
        xxf:expose-xpath-types="true"
        xxf:exclude-result-prefixes="#all">
        <response>
            <document-id/>
            <process-success>true</process-success>
        </response>
    </xf:instance>

    <xf:bind
        ref="instance('fr-background-response-instance')/process-success"
        type="xs:boolean"/>

    <xf:submission
        id="fr-send-background-response"
        ref="instance('fr-background-response-instance')"
        method="post"
        action="echo:"
        replace="all"/>

    <!-- Run "form load" processes if they exist, see https://github.com/orbeon/orbeon-forms/issues/3318 -->
    <xf:action
        observer="fr-form-model"
        event="
            xxforms-instances-ready
            xforms-model-construct-done
            xforms-ready">

        <xf:var
            name="process-property-name"
            value="
                string-join(
                    (
                        'oxf.fr.detail.process',
                        for $name in event('xxf:type')
                        return
                            if ($name = 'xxforms-instances-ready') then
                                'before-data'
                            else if ($name = 'xforms-model-construct-done') then
                                'after-data'
                            else if ($name = 'xforms-ready') then
                                'after-controls'
                            else
                                error(
                                    QName('http://orbeon.org/oxf/xml/form-runner', 'fr:illegal-state'),
                                    concat('unexpected event received: ', $name)
                                ),
                        if ($is-export) then
                            'export'
                        else if ($is-background) then
                            'background'
                        else
                            'foreground',
                        $mode
                    ),
                    '.'
                )"/>

        <xf:var
            name="process-property-value"
            value="frf:xpathFormRunnerStringProperty($process-property-name)"/>

        <!-- Run service if defined -->
        <xf:action if="exists($process-property-value)">

            <xf:var
                name="process-result"
                value="fr:run-process('oxf.fr.detail.process', $process-property-value)"/>

            <xf:setvalue
                if="exists($process-result)"
                ref="instance('fr-background-response-instance')/process-success"
                value="data(.) and $process-result"/>

            <!-- Log error if any -->
            <xf:message
                if="not($process-result)"
                level="xxf:log-error"
                value="concat('Process failed with error for property: `', $process-property-name, '`')"/>

            <xf:message
                level="xxf:log-debug"
                value="concat('Result of running process with property: `', $process-property-name, '`: ', $process-result)"/>

        </xf:action>

        <!-- When done in background mode, send out service response -->
        <xf:action if="$is-background and event('xxf:type') = 'xforms-ready'">

            <xf:setvalue
                ref="instance('fr-background-response-instance')/document-id"
                value="fr:document-id()"/>

            <xf:delete
                ref="instance('fr-background-response-instance')/data"/>

            <xf:action
                if="instance('fr-background-response-instance')/process-success/data(.) and (: process must be successful :)
                    (
                        $is-export                                                      or  (: export causes data out     :)
                        (
                            xxf:get-request-parameter('return-data') = 'true'           and (: caller must request data   :)
                            xxf:property(                                                   (: the property allows it     :)
                                string-join(
                                    (
                                        'oxf.fr.detail.service',
                                         if ($is-background) then 'background' else 'foreground',
                                         'enable-return-data',
                                         $app,
                                         $form
                                     ),
                                    '.'
                                )
                            )
                        )
                    )">

                <xf:insert
                    ref="instance('fr-background-response-instance')/document-id"
                    origin="
                        let $data-format-version  :=
                                if ($is-export) then
                                    '2019.1.0' (: don't use the parameter as the output is only used internally :)
                                 else
                                    (xxf:get-request-parameter('data-format-version'), '4.0.0')[1],
                            $prune-metadata-param := xxf:get-request-parameter('prune-metadata'),
                            $prune-metadata       :=
                                if ($is-export) then
                                    false() (: don't use the parameter as the output is only used internally :)
                                else if (exists($prune-metadata-param)) then
                                    $prune-metadata-param = 'true'
                                else if ($data-format-version = 'edge') then
                                    false()
                                else
                                    true()
                        return
                            xf:element(
                                'data',
                                grid-migration:dataMaybeMigratedFromEdge(
                                   fr:app-name(),
                                   fr:form-name(),
                                   xxf:instance('fr-form-instance')/root(),
                                   xxf:instance('fr-form-metadata')/root(),
                                   $data-format-version,
                                   $prune-metadata
                               )
                            )
                    "
                />

            </xf:action>

            <xf:send submission="fr-send-background-response"/>

        </xf:action>

    </xf:action>

    <xf:action event="xforms-model-construct-done" observer="fr-form-model">
        <xf:dispatch
            if="xxf:is-blank(instance('fr-persistence-instance')/found-document-message-to-show)"
            name="fr-run-form-load-action-after-data"
            targetid="fr-form-model"/>
    </xf:action>

    <xf:action event="xforms-ready" observer="fr-form-model">
        <xf:dispatch
            if="xxf:is-blank(instance('fr-persistence-instance')/found-document-message-to-show)"
            name="fr-run-form-load-action-after-controls"
            targetid="fr-form-model"/>
    </xf:action>

    <xf:action event="xforms-ready">
        <!-- Force all this so we can safely set the data status -->
        <xf:rebuild/>
        <xf:recalculate/>
        <xf:refresh/>
        <!-- Set the initial data status -->
        <xf:setvalue
            iterate="($persistence-instance/data-status, $autosave-elem/status)"
            ref="."
            value="../initial-data-status"/>
    </xf:action>

    <!-- Clear operation -->
    <xf:action event="fr-clear">

        <xf:insert
            ref="xxf:instance('fr-form-instance')"
            origin="instance('fr-initial-instance')"/>

        <!-- Notify that the data is reset -->
        <xf:dispatch targetid="fr-form-model" name="fr-data-reset"/>

        <!-- Perform refresh (above sets RRR flags already) so that after that we can clear error summary -->
        <xf:refresh/>

        <!-- Clear error summary and focus -->
        <xf:dispatch name="fr-unvisit-all" targetid="fr-error-summary-model"/>
        <xf:setfocus
            control="fr-view-component"
            includes="{frf:xpathFormRunnerStringProperty('oxf.fr.detail.focus.includes')}"
            excludes="{frf:xpathFormRunnerStringProperty('oxf.fr.detail.focus.excludes')}"/>
    </xf:action>

    <!-- New document operation -->
    <xf:setvalue event="fr-new-document" ref="$document-element" value="secure:randomHexId()"/>

    <!-- Delete operation -->
    <xf:action event="fr-delete-data">
        <xf:send submission="fr-delete-document-submission">
            <xf:property name="document-data-or-draft-id" value="event('document-data-or-draft-id')"/>
        </xf:send>
    </xf:action>

    <xf:submission id="fr-delete-document-submission"
            method="delete"
            serialization="none"
            resource="/fr/service/persistence/crud/{$app}/{$form}/{event('document-data-or-draft-id')}/data.xml"
            replace="none"/>

    <!-- Search for drafts, to possibly warn users there is a newer draft -->
    <xf:submission id="fr-search-submission"
            method="post"
            resource="/fr/service/persistence/search/{$app}/{$form}"
            ref="instance('fr-search-request')"
            replace="instance"
            instance="fr-search-response">
        <xf:header ref="$form-version[xxf:non-blank()]">
            <xf:name>Orbeon-Form-Definition-Version</xf:name>
            <xf:value value="."/>
        </xf:header>
        <!-- Remove documents we can't update (search might still return them if we can only ready them) -->
        <xf:delete
            event="xforms-submit-done"
            ref="instance('fr-search-response')/document[not(xxf:split(@operations) = ('*', 'update'))]"/>
    </xf:submission>
    <xf:instance id="fr-search-request">
        <search>
            <page-size>10</page-size>
            <page-number>1</page-number>
            <lang>en</lang>
        </search>
    </xf:instance>
    <xf:instance id="fr-search-response"><dummy/></xf:instance>

    <xf:instance id="fr-lockinfo-request">
        <d:lockinfo>
            <d:lockscope><d:exclusive/></d:lockscope>
            <d:locktype><d:write/></d:locktype>
            <d:owner>
                <fr:username/>
                <fr:groupname/>
            </d:owner>
        </d:lockinfo>
    </xf:instance>
    <xf:instance id="fr-lockinfo-response">
        <d:lockinfo/>
    </xf:instance>
    <xf:submission
        id="fr-acquire-lease-submission"
        method="lock"
        ref="instance('fr-lockinfo-request')"
        resource="/fr/service/persistence/crud/{$app}/{$form}/data/{$document}/data.xml"
        replace="none"
    >
        <xf:header>
            <xf:name>Timeout</xf:name>
            <xf:value value="concat('Second-', $lease-duration-elem * 60)"/>
        </xf:header>
        <xf:action event="xforms-submit-done">
            <!-- We acquired a lease: proceed with loading the document -->
            <xf:setvalue ref="$lease-state-elem">current-user</xf:setvalue>
            <xf:setvalue
                ref="$persistence-instance/lease-start-time"
                value="current-dateTime()"/>
            <xf:setvalue
                ref="$persistence-instance/lease-end-time"
                value="
                    current-dateTime() +
                    xs:dayTimeDuration(concat('PT', $persistence-instance/lease-duration, 'M'))
                "/>
            <xf:action if="$persistence-instance/lease-load-document = 'true'">
                <xf:setvalue ref="$persistence-instance/lease-load-document"/>
                <xf:dispatch name="fr-load-document" target="fr-persistence-model"/>
            </xf:action>
        </xf:action>
        <xf:action event="xforms-submit-error">
            <!-- We failed to acquire a lease -->
            <xf:insert ref="instance('fr-lockinfo-response')" origin="event('response-body')"/>
            <xf:setvalue ref="$lease-state-elem">other-user</xf:setvalue>
        </xf:action>
    </xf:submission>
    <xf:submission
        id="fr-relinquish-lease-submission"
        method="unlock"
        ref="instance('fr-lockinfo-request')"
        resource="/fr/service/persistence/crud/{$app}/{$form}/data/{$document}/data.xml"
        replace="none"/>

    <!-- Get document -->
    <xf:submission
        xmlns:frp="java:org.orbeon.oxf.fr.FormRunnerPersistenceJava"

        id="fr-get-document-submission"
        method="get"
        serialization="none"
        resource="/fr/service/persistence/crud/{
                $app
            }/{
                $form
            }/{
                event('data-or-draft')
            }/{
                $document
            }/data.xml?data-format-version={

                (: Tell the persistence layer the format we expect for the configured provider. This gives
                   the persistence layer a chance to check that the format is compatible and throw an error
                   if not. Later, once the persistence proxy can perform conversions, we will be able to
                   directly request the format we need. See https://github.com/orbeon/orbeon-forms/issues/3110 :)

                frp:providerDataFormatVersion($app, $form)
            }"
        replace="instance"
        xxf:instance="fr-form-instance">

        <xf:action event="xforms-submit-done">
            <!-- Save value of Orbeon-Operations header -->
            <xf:var
                name="operations-header"
                value="event('response-headers')[lower-case(name) = 'orbeon-operations']/value"/>
            <xf:insert
                if="exists($operations-header)"
                context="instance('fr-authorized-operations')"
                origin="xf:attribute('from-persistence', $operations-header/string())"/>
            <!-- Save value of the Orbeon-Workflow-Stage header -->
            <xf:setvalue
                ref="instance('fr-document-metadata')/@workflow-stage"
                value="
                    let
                        $header          := event('response-headers')[lower-case(name) = 'orbeon-workflow-stage']/value,
                        $stage-value     := if (empty($header)) then '' else $header/string()
                    return
                        $stage-value"/>
            <!-- Save value of date headers -->
            <xf:insert
                context="instance('fr-document-metadata')"
                origin="
                    for $header in event('response-headers')[
                        lower-case(name) = ('created', 'last-modified')
                    ]
                    return
                        xf:attribute(lower-case($header/name/string()), $header/value/string())"/>
            <!-- Remove `relevant` attributes (#3065) -->
            <xf:delete
                ref="xxf:instance('fr-form-instance')//(@xxf:relevant, @fr:relevant)"/>
        </xf:action>
    </xf:submission>

    <!-- Calls a service to get the initial instance -->
    <xf:submission id="fr-get-instance-from-service"
        method="get"
        serialization="none"
        resource="{frf:createNewFromServiceUrlOrEmpty($app, $form)}"
        replace="none"/>

    <!-- Migrate data if needed when loading instance from the persistence layer or a service.

         NOTE: Ideally this would just a be a transformation *before* the submission replaces the node in
         fr-form-instance. Here, replacement takes place, and then we replace again with the updated data.
     -->
    <xf:action event="xforms-submit-done" observer="fr-get-document-submission">
        <xf:insert
            context="xxf:instance('fr-form-instance')/root()"
            origin="
                let
                    $format-migrated :=
                        grid-migration:dataMaybeMigratedFromDatabaseFormat(
                            $app,
                            $form,
                            root(),
                            xxf:instance('fr-form-metadata')/root()
                        )/root()/*,
                    $simply-migrated :=
                        simple-migration:dataMaybeWithSimpleMigration(
                            xxf:absolute-id('fr-form-model'),
                            instance('fr-initial-instance'),
                            $format-migrated
                        )
                return
                    if (exists($simply-migrated)) then
                        $simply-migrated
                    else
                        $format-migrated
                "/>

        <xf:message level="xxf:log-debug">Rebuild/recalculate after loading doc</xf:message>
        <xf:rebuild     model="fr-form-model"/>
        <xf:recalculate model="fr-form-model"/>

    </xf:action>

    <xf:action
        event="xforms-submit-done"
        observer="fr-get-instance-from-service">

        <!-- See https://github.com/orbeon/orbeon-forms/issues/3935 -->
        <xf:var
            name="body"
            value="event('response-body')"/>

        <xf:var
            name="is-xml"
            value="($body instance of element()) or ($body instance of document-node())"/>

        <xf:action if="$is-xml">

            <xf:var
                name="body-migrated"
                as="document-node()"
                value="
                    grid-migration:dataMigratedToEdge(
                        $app,
                        $form,
                        $body/root(),
                        xxf:instance('fr-form-metadata')/root(),
                        '4.0.0' (: as documented as of 2019.1 :)
                    )"/>

            <!-- Be consistent with `fr-get-document-submission` -->
            <xf:delete
                ref="$body-migrated//(@xxf:relevant, @fr:relevant)"/>

            <!-- See https://github.com/orbeon/orbeon-forms/issues/3935 -->
            <xf:insert
                context="xxf:instance('fr-form-instance')/root()"
                origin="$body-migrated"/>

        </xf:action>
        <xf:action if="not($is-xml)">
            <!-- Ignore for compatibility, see https://github.com/orbeon/orbeon-forms/issues/3935. -->
        </xf:action>
    </xf:action>

    <xf:action
        event="xforms-submit-error"
        observer="fr-get-instance-from-service">

        <xf:action type="xpath">
            frf:sendError(500)
        </xf:action>

    </xf:action>

    <!-- Initial instance (to support clear) -->
    <xf:instance id="fr-initial-instance" xxf:readonly="false"><!-- Set to false so that `xf:insert` works -->
        <form xmlns=""/>
    </xf:instance>

    <!-- Which operations the user can perform -->
    <xf:instance id="fr-authorized-operations">
        <operations/>
    </xf:instance>

    <!-- Metadata associated with a GET of the document -->
    <xf:instance id="fr-document-metadata">
        <metadata workflow-stage=""/>
    </xf:instance>

    <xf:instance id="fr-persistence-instance">
        <save xmlns="">
            <!-- Dialog to show upon xforms-ready for handling drafts -->
            <found-document-message-to-show/>
            <!-- Initial data status -->
            <initial-data-status>clean</initial-data-status>
            <!-- Whether form data is clean or dirty (i.e. saved or not saved) -->
            <data-status>clean</data-status>
            <autosave>
                <status>clean</status>
                <autosave-timestamp/>
            </autosave>
            <!-- Success or error message to display -->
            <message/>
            <!-- Error document returned -->
            <error/>
            <!-- Flag to override data-safe -->
            <data-safe-override/>
            <!-- Whether data is safe -->
            <data-safe/>
            <!-- Is the captcha valid: start with false, will set it to true when valid -->
            <captcha>false</captcha>
            <lease-enabled/>
            <!-- When lease-enabled = 'true': other-user | current-user | relinquished -->
            <lease-state/>
            <lease-load-document/>
            <lease-duration/>
            <lease-renew-threshold/>
            <lease-alert-threshold/>
            <lease-start-time/>
            <lease-end-time/>
            <lease-owned-by-current-user/>
        </save>
    </xf:instance>

    <!-- Watch data-status and dispatch fr-data-status-changed -->
    <xf:action
        event="xxforms-value-changed"
        observer="fr-persistence-instance"
        if="name(event('node')) = 'data-status' and event('old-value') != event('new-value')">
        <xf:dispatch name="fr-data-status-changed" targetid="fr-persistence-model">
            <xf:property name="data-status" value="event('new-value')"/>
        </xf:dispatch>
    </xf:action>

    <xf:bind ref="$persistence-instance">
        <xf:bind ref="data-safe" calculate="../data-status = 'clean' or ../data-safe-override = 'true'"/>
        <xf:bind ref="captcha" constraint=". = 'true'"/>
        <xf:bind
            ref="lease-owned-by-current-user"
            calculate="
                ../lease-enabled != 'true' or
                (
                    ../lease-state = 'current-user' and
                    current-dateTime() le xs:dateTime(../lease-end-time)
                )"/>
    </xf:bind>

    <!-- Configuration for Saxon serialization -->
    <xf:instance id="fr-xsl-output-instance">
        <xsl:output xmlns:xsl="http://www.w3.org/1999/XSL/Transform" method="xml" omit-xml-declaration="yes" indent="yes" saxon:indent-spaces="4"/>
    </xf:instance>

    <!-- Instance to store suspended processes -->
    <xf:instance id="fr-processes-instance">
        <processes/>
    </xf:instance>

    <xf:instance id="fr-triggers-instance">
        <triggers xmlns="">
            <strict-submit/>
            <can-access-summary/>
            <pdf/>
            <tiff/>
            <other/>
        </triggers>
    </xf:instance>

    <xf:bind ref="instance('fr-triggers-instance')">
        <!--
            NOTE: Don't disable basic save/submit buttons so that user can always press it. This arguably yields a
            better experience in non-incremental mode and also allows user to force showing errors.
        -->

        <!-- NOTE: As of 2013-04-04, only used for PDF button which uses fr:href-button -->
        <xf:bind ref="strict-submit"
                 readonly="(xxf:instance('fr-error-summary-instance')/valid = false() or xxf:pending-uploads() > 0)"/>

        <!-- Show summary button if users have the read permission (obviously), but also if they are logged in, as in
             that case they might be able to see data based on ownership -->
        <xf:bind ref="can-access-summary"
                 relevant="xxf:split(instance('fr-authorized-operations')) = ('*', 'read')
                           or xxf:non-blank(xxf:username())"/>
        <!-- Don't show the PDF button at all in CE version if there is a PDF template -->
        <xf:bind ref="pdf"
                 relevant="not((xxf:instance('fr-form-attachments')/pdf/xxf:trim() != '')) or fr:is-pe()"
                 readonly="xxf:property(string-join(('oxf.fr.detail.pdf.disable-if-invalid', $app, $form), '.'))
                           and xxf:readonly(../strict-submit)"/>

        <!-- Don't show the TIFF button at all in CE version -->
        <xf:bind ref="tiff"
                 relevant="fr:is-pe()"
                 readonly="xxf:property(string-join(('oxf.fr.detail.pdf.disable-if-invalid', $app, $form), '.'))
                           and xxf:readonly(../strict-submit)"/>
    </xf:bind>

    <!-- HACK: dependencies: recalculate this model when there is a change in the instance holding error/validity
         information, so that the above binds are kept in sync. Ideally would need smart dependency system. -->
    <xf:recalculate event="xxforms-value-changed" observer="fr-error-summary-instance"/>

    <!-- Series of temporary URLs for PDF/TIFF generation -->
    <xf:instance id="fr-urls-instance" xxf:exclude-result-prefixes="#all">
        <urls/>
    </xf:instance>

    <xf:bind ref="instance('fr-urls-instance')/*" type="xs:anyURI"/>

    <!-- React to issue loading the document. We consider this fatal. -->
    <xf:action event="xforms-submit-error" target="fr-get-document-submission" type="xpath">
        frf:sendError((event('response-status-code'), 500)[1])
    </xf:action>

    <!-- Clear message -->
    <xf:action observer="#document" event="DOMFocusIn">
        <xf:toggle case="fr-message-none" xxf:deferred-updates="false"/>
        <xf:setvalue ref="$persistence-instance/message"/>
    </xf:action>

    <!-- React to instance mutation events -->
    <!-- NOTE: We check the standard fr-form-instance, but also fb-form-instance, which is where Form Builder really does its work  -->
    <xf:action observer="fr-form-instance fb-form-instance" event="xforms-insert xforms-delete xxforms-replace xxforms-value-changed">
        <xf:action if="
            $mode = ('new', 'edit') and (
                (: https://github.com/orbeon/orbeon-forms/issues/5233 :)
                let $nodes :=
                    if (event('xxf:type')      = 'xforms-insert')         then
                        event('inserted-nodes')
                    else if (event('xxf:type') = 'xforms-delete')         then
                        event('deleted-nodes')
                    else if (event('xxf:type') = 'xxforms-replace')       then
                        event('current-node')
                    else if (event('xxf:type') = 'xxforms-value-changed') then
                        event('node')
                    else
                        (),
                    (: in theory, `insert`/`delete` can affect more than one node but this doesn't happen in the wizard :)
                    $att := $nodes[..//@fr:section-status is .]
                return
                    empty($att)
            )">

            <!-- Mark status as dirty if data changes -->
            <xf:setvalue ref="$persistence-instance/data-status"          value="'dirty'"/>
            <!-- Reset override, see: https://github.com/orbeon/orbeon-forms/issues/1325  -->
            <xf:setvalue ref="$persistence-instance/data-safe-override"   value="'false'"/>
            <xf:action if="$autosave-enabled">
                <xf:setvalue ref="$autosave-elem/status"                  value="'dirty'"/>
                <xf:dispatch
                    name="maybe-autosave"
                    targetid="fr-persistence-model"
                    delay="{$autosave-delay}"
                    xxf:show-progress="false"/>
            </xf:action>
        </xf:action>
        <xf:action
            if="
                $mode = 'edit' and
                $lease-state-elem = 'current-user' and
                current-dateTime() ge
                    xs:dateTime($persistence-instance/lease-start-time) +
                    xs:dayTimeDuration(concat('PT', $persistence-instance/lease-renew-threshold, 'M'))">
            <xf:send submission="fr-acquire-lease-submission"/>
        </xf:action>
    </xf:action>

    <xf:action event="maybe-autosave">
        <xf:var
            name="do-autosave"
            value="
                $autosave-elem/status                             = 'dirty' and
                $persistence-instance/lease-owned-by-current-user = 'true'  and
                $persistence-instance/found-document-message-to-show      = ''
            "/>
        <xf:action if="$do-autosave">
            <xf:var
                name="delay"
                value="xs:dayTimeDuration(concat('PT', $autosave-delay div 1000, 'S'))"/>
            <xf:var
                name="do-autosave-now"
                value="
                    (: We've never autosaved before :)
                    $autosave-elem/autosave-timestamp = '' or
                    (: Enough time has passed since the last autosave :)
                    xs:dateTime($autosave-elem/autosave-timestamp) + $delay le current-dateTime()
                "/>

            <xf:action if="$do-autosave-now">
                <xf:setvalue ref="$autosave-elem/autosave-timestamp" value="current-dateTime()"/>
                <xf:action type="xpath">fr:run-process-by-name('oxf.fr.detail.process', 'autosave')</xf:action>
            </xf:action>

            <xf:action if="not($do-autosave-now)">
                <xf:var
                    name="autosave-timestamp"
                    value="xs:dateTime($autosave-elem/autosave-timestamp)"/>
                <xf:var
                    name="wait-duration"
                    value="($autosave-timestamp + $delay) - current-dateTime()"/>
                <xf:var name="wait-milliseconds" value="
                    (
                        minutes-from-duration($wait-duration) * 60 +
                        seconds-from-duration($wait-duration)
                    ) * 1000"/>
                <xf:dispatch
                    if="not($autosave-now)"
                    name="maybe-autosave"
                    targetid="fr-persistence-model"
                    delay="{$wait-milliseconds}"
                    xxf:show-progress="false"/>
            </xf:action>
        </xf:action>
    </xf:action>

    <!-- Handler for missing attachments, see https://github.com/orbeon/orbeon-forms/issues/1529 -->
    <xf:action
        event="xxforms-state-restored"
        observer="#document"
        target="#document">

        <xf:var
            name="filenames"
            value="frf:clearMissingUnsavedDataAttachmentReturnFilenamesJava(xxf:instance('fr-form-instance'))"/>

        <xf:action if="exists($filenames)">
            <xf:message ref="xxf:r('detail.messages.lost-attachments', '|fr-fr-resources|')"/>
        </xf:action>


    </xf:action>

</xf:model>
